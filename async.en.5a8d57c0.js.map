{"version":3,"file":"async.en.5a8d57c0.js","mappings":"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","sources":["webpack://gi_builds/./node_modules/locmap/src/map.js","webpack://gi_builds/./node_modules/js-control/src/index.js","webpack://gi_builds/./node_modules/locmap/src/control_layer.js","webpack://gi_builds/./node_modules/locmap/src/utils.js","webpack://gi_builds/./node_modules/locmap/src/tile_container.js","webpack://gi_builds/./node_modules/locmap/src/tile_layer.js","webpack://gi_builds/./node_modules/teyvat-map/lib/tiles/summary.js","webpack://gi_builds/./www/src/components/teyvat-map.tsx","webpack://gi_builds/./lib/utils/web_media.js"],"sourcesContent":["/**\n * @typedef {{\n *   x2lon(x:number, zoom:number):number,\n *   y2lat(y:number, zoom:number):number,\n *   lon2x(lon:number, zoom:number):number,\n *   lat2y(lat:number, zoom:number):number,\n *   meters2pixCoef(lat:number, zoom:number):number,\n * }} ProjectionConverter\n */\n\n/**\n * @template T\n * @typedef {(map:LocMap, params:T) => unknown} MapEventHandler\n */\n\n/**\n * @typedef {{\n *   [K in keyof import('./common_types').MapEventHandlersMap]?:\n *     MapEventHandler<import('./common_types').MapEventHandlersMap[K]>\n * } & Record<string, MapEventHandler<any>>} MapEventHandlers\n */\n\n/**\n * @typedef {{\n *   register?(map:LocMap): unknown,\n *   unregister?(map:LocMap): unknown,\n *   update?(map:LocMap): unknown,\n *   redraw?(map:LocMap): unknown,\n *   onEvent?: MapEventHandlers,\n * }} MapLayer\n */\n\n/**\n * Core map engine. Manages location, layers and some transition animations.\n * @class\n * @param {HTMLElement} wrap main map element, should be relative/absolute for canvas to scale correctly\n * @param {ProjectionConverter} conv projection config, usually `ProjectionMercator`\n */\nexport function LocMap(wrap, conv) {\n\tconst rect = wrap.getBoundingClientRect()\n\tlet curWidth = rect.width\n\tlet curHeight = rect.height\n\n\tlet lon = 0\n\tlet lat = 0\n\tlet zoom = 256\n\tlet xShift = 0\n\tlet yShift = 0\n\tlet minZoom = 0\n\tlet maxZoom = Infinity\n\n\tthis.getLon = () => lon\n\tthis.getLat = () => lat\n\tthis.getZoom = () => zoom\n\tthis.getProjConv = () => conv\n\t/**\n\t * Map top-left edge offset from the view center (in pixels)\n\t * @returns {[x:number, y:number]}\n\t */\n\tthis.getShift = () => [xShift, yShift]\n\t/** Returns current projection config */\n\t/**\n\t * Map top-left edge offset from the view top-left edge (in pixels)\n\t * @returns {[x:number, y:number]}\n\t */\n\tthis.getViewBoxShift = () => [xShift - curWidth / 2, yShift - curHeight / 2]\n\t/**\n\t * Map view size\n\t * @returns {[x:number, y:number]}\n\t */\n\tthis.getViewBoxSize = () => [curWidth, curHeight]\n\n\t/**\n\t * Returns min and max zoom\n\t * @returns {[min:number, max:number]}\n\t */\n\tthis.getZoomRange = () => [minZoom, maxZoom]\n\t/**\n\t * Sets min and max zoom. Does not clamp current zoom.\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\tthis.setZoomRange = (min, max) => {\n\t\tminZoom = min\n\t\tmaxZoom = max\n\t}\n\n\tconst canvas = document.createElement('canvas')\n\tcanvas.className = 'locmap-canvas'\n\tcanvas.style.position = 'absolute'\n\tcanvas.style.left = '0'\n\tcanvas.style.top = '0'\n\tcanvas.style.width = '100%'\n\tcanvas.style.height = '100%'\n\twrap.appendChild(canvas)\n\tconst rc = canvas.getContext('2d')\n\n\tthis.getWrap = () => wrap\n\tthis.getCanvas = () => canvas\n\tthis.get2dContext = () => rc\n\n\tfunction pos_screen2map() {\n\t\tlon = conv.x2lon(xShift, zoom)\n\t\tlat = conv.y2lat(yShift, zoom)\n\t}\n\tfunction pos_map2screen() {\n\t\txShift = conv.lon2x(lon, zoom)\n\t\tyShift = conv.lat2y(lat, zoom)\n\t}\n\n\t/** @param {number} lon */\n\tthis.lon2x = lon => {\n\t\treturn conv.lon2x(lon, zoom)\n\t}\n\t/** @param {number} lat */\n\tthis.lat2y = lat => {\n\t\treturn conv.lat2y(lat, zoom)\n\t}\n\t/** @param {number} lat */\n\tthis.meters2pixCoef = lat => {\n\t\treturn conv.meters2pixCoef(lat, zoom)\n\t}\n\t/** @param {number} x */\n\tthis.x2lon = x => {\n\t\treturn conv.x2lon(x, zoom)\n\t}\n\t/** @param {number} y */\n\tthis.y2lat = y => {\n\t\treturn conv.y2lat(y, zoom)\n\t}\n\n\t//----------\n\t// core\n\t//----------\n\n\tconst layers = /** @type {MapLayer[]} */ ([])\n\t/** @param {MapLayer} layer */\n\tthis.register = layer => {\n\t\tif (layers.includes(layer)) throw new Error('already registered')\n\t\tlayers.push(layer)\n\t\tif (layer.register) layer.register(this)\n\t}\n\t/** @param {MapLayer} layer */\n\tthis.unregister = layer => {\n\t\tconst pos = layers.indexOf(layer)\n\t\tif (pos === -1) throw new Error('not registered yet')\n\t\tlayers.splice(pos, 1)\n\t\tif (layer.unregister) layer.unregister(this)\n\t}\n\t/** @returns {readonly MapLayer[]} */\n\tthis.getLayers = () => layers\n\n\t/**\n\t * Instantly update map location and zoom.\n\t * @param {number} lon_\n\t * @param {number} lat_\n\t * @param {number} zoom_\n\t */\n\tthis.updateLocation = (lon_, lat_, zoom_) => {\n\t\tlon = lon_\n\t\tlat = lat_\n\t\tzoom = zoom_\n\t\tpos_map2screen()\n\t\tupdateLayers()\n\t\trequestRedraw()\n\t}\n\n\tconst updateLayers = () => {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = layers[i]\n\t\t\tif (layer.update) layer.update(this)\n\t\t}\n\t}\n\tconst drawLayers = () => {\n\t\tif (rc === null) return\n\t\trc.clearRect(0, 0, canvas.width, canvas.height)\n\t\trc.scale(devicePixelRatio, devicePixelRatio)\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = layers[i]\n\t\t\tif (layer.redraw) layer.redraw(this)\n\t\t}\n\t\trc.scale(1 / devicePixelRatio, 1 / devicePixelRatio)\n\t}\n\n\tconst ZOOM_ANIM_MODE_SMOOTH = 0\n\tconst ZOOM_ANIM_MODE_INERTIA = 1\n\tconst zoomAnimationMinSpeed = 0.0001 //zoom_change/ms\n\tconst zoomInertiaDeceleration = 0.993\n\tconst zoomSmoothDeceleration = 0.983\n\tlet zoomAnimationMode = /**@type {0|1}*/ (ZOOM_ANIM_MODE_SMOOTH)\n\tlet zoomAnimationPrevStamp = 0\n\tlet zoomAnimationX = 0\n\tlet zoomAnimationY = 0\n\tlet zoomAnimationDelta = 1\n\n\tconst MOVE_ANIM_MODE_SMOOTH = 0\n\tconst MOVE_ANIM_MODE_INERTIA = 1\n\tconst moveInertiaDeceleration = 0.993 //relative speed decrease per 1ms\n\tconst moveSmoothDeceleration = 0.985\n\tconst moveAnimationMinSpeed = 0.01 //pixels/ms\n\tlet moveAnimationMode = /**@type {0|1}*/ (MOVE_ANIM_MODE_SMOOTH)\n\tlet moveAnimationPrevStamp = 0\n\tlet moveAnimationX = 0\n\tlet moveAnimationY = 0\n\n\t/** @param {number} frameTime */\n\tconst smoothIfNecessary = frameTime => {\n\t\tconst now = frameTime\n\n\t\tif (Math.abs(zoomAnimationDelta - 1) > zoomAnimationMinSpeed) {\n\t\t\tconst elapsed = now - zoomAnimationPrevStamp\n\n\t\t\tlet dz\n\t\t\tif (zoomAnimationMode === ZOOM_ANIM_MODE_INERTIA) {\n\t\t\t\tdz = zoomAnimationDelta ** elapsed\n\t\t\t\tconst inertiaK = zoomInertiaDeceleration ** elapsed\n\t\t\t\tzoomAnimationDelta = 1 + (zoomAnimationDelta - 1) * inertiaK\n\t\t\t} else {\n\t\t\t\tconst smoothK = zoomSmoothDeceleration ** elapsed\n\t\t\t\tlet newSmoothDelta = 1 + (zoomAnimationDelta - 1) * smoothK\n\t\t\t\tif (Math.abs(newSmoothDelta - 1) <= zoomAnimationMinSpeed) newSmoothDelta = 1\n\t\t\t\tdz = zoomAnimationDelta / newSmoothDelta\n\t\t\t\tzoomAnimationDelta = newSmoothDelta\n\t\t\t}\n\n\t\t\tthis.zoom(zoomAnimationX, zoomAnimationY, dz)\n\t\t\tzoomAnimationPrevStamp = now\n\t\t}\n\n\t\tif (moveAnimationX ** 2 + moveAnimationY ** 2 > moveAnimationMinSpeed ** 2) {\n\t\t\tconst elapsed = now - moveAnimationPrevStamp\n\n\t\t\tlet dx, dy\n\t\t\tif (moveAnimationMode === MOVE_ANIM_MODE_INERTIA) {\n\t\t\t\tdx = moveAnimationX * elapsed\n\t\t\t\tdy = moveAnimationY * elapsed\n\t\t\t\tconst k = moveInertiaDeceleration ** elapsed\n\t\t\t\tmoveAnimationX *= k\n\t\t\t\tmoveAnimationY *= k\n\t\t\t} else {\n\t\t\t\tlet k = moveSmoothDeceleration ** elapsed\n\t\t\t\tlet newX = moveAnimationX * k\n\t\t\t\tlet newY = moveAnimationY * k\n\t\t\t\tif (newX ** 2 + newY ** 2 < moveAnimationMinSpeed ** 2) k = 0\n\t\t\t\tdx = moveAnimationX * (1 - k)\n\t\t\t\tdy = moveAnimationY * (1 - k)\n\t\t\t\tmoveAnimationX *= k\n\t\t\t\tmoveAnimationY *= k\n\t\t\t}\n\n\t\t\tthis.move(dx, dy)\n\t\t\tmoveAnimationPrevStamp = now\n\t\t}\n\t}\n\n\tlet animFrameRequested = false\n\tfunction requestRedraw() {\n\t\tif (!animFrameRequested) {\n\t\t\tanimFrameRequested = true\n\t\t\trequestAnimationFrame(onAnimationFrame)\n\t\t}\n\t}\n\t/** @param {number} frameTime */\n\tfunction onAnimationFrame(frameTime) {\n\t\tanimFrameRequested = false\n\t\t// On some browsers frameTime is not a callback call time but last VSync time:\n\t\t// https://stackoverflow.com/questions/64177381/timestamp-of-requestanimationframe-is-not-reliable\n\t\t// So this frame time can be LESS than event.timeStamp in touch event (for example)\n\t\t// even if current animation frame callback was called AFTER touch event callback.\n\t\t// Because of that frameTime can not be used for animation in smoothIfNecessary().\n\t\tsmoothIfNecessary(performance.now())\n\t\tdrawLayers()\n\t}\n\t/** Schedules map redraw (unless already scheduled). Can be safelly called multiple times per frame. */\n\tthis.requestRedraw = requestRedraw\n\n\t//-------------------\n\t// control inner\n\t//-------------------\n\n\t/**\n\t * Should be called after map element (`wrap`) resize to update internal state and canvas.\n\t */\n\tthis.resize = () => {\n\t\tconst rect = wrap.getBoundingClientRect()\n\n\t\tcanvas.width = rect.width * devicePixelRatio\n\t\tcanvas.height = rect.height * devicePixelRatio\n\n\t\tcurWidth = rect.width\n\t\tcurHeight = rect.height\n\n\t\trequestRedraw()\n\t}\n\n\t/**\n\t * Zoom in `delta` times using `(x,y)` as a reference point\n\t * (stays in place when zooming, usually mouse position).\n\t * `0 < zoom < 1` for zoom out.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} delta\n\t */\n\tthis.zoom = (x, y, delta) => {\n\t\tconst prevZoom = zoom\n\t\tzoom = mutlClamp(minZoom, maxZoom, zoom, delta)\n\t\tconst actualDelta = zoom / prevZoom\n\t\txShift += (-x + curWidth / 2 - xShift) * (1 - actualDelta)\n\t\tyShift += (-y + curHeight / 2 - yShift) * (1 - actualDelta)\n\t\tpos_screen2map()\n\n\t\tupdateLayers()\n\t\trequestRedraw()\n\t\tthis.emit('mapZoom', { x, y, delta })\n\t}\n\n\t/**\n\t * Zoom in `delta` times smoothly using `(x,y)` as a reference point.\n\t * Motion resembles `ease-out`, i.e. slowing down to the end.\n\t * Useful for handling zoom buttons and mouse wheel.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} delta\n\t * @param {number} stamp zoom start time, usually `event.timeStamp` or `performance.now()`\n\t */\n\tthis.zoomSmooth = (x, y, delta, stamp) => {\n\t\tif (zoomAnimationMode !== ZOOM_ANIM_MODE_SMOOTH) zoomAnimationDelta = 1\n\t\tzoomAnimationDelta = mutlClamp(minZoom / zoom, maxZoom / zoom, zoomAnimationDelta, delta)\n\t\tzoomAnimationX = x\n\t\tzoomAnimationY = y\n\t\tzoomAnimationPrevStamp = stamp\n\t\tzoomAnimationMode = ZOOM_ANIM_MODE_SMOOTH\n\t\tsmoothIfNecessary(stamp)\n\t}\n\n\t/**\n\t * Move map view by `(dx,dy)` pixels.\n\t * @param {number} dx\n\t * @param {number} dy\n\t */\n\tthis.move = (dx, dy) => {\n\t\txShift -= dx\n\t\tyShift -= dy\n\t\tpos_screen2map()\n\n\t\tupdateLayers()\n\t\trequestRedraw()\n\t\tthis.emit('mapMove', { dx, dy })\n\t}\n\n\t/**\n\t * Move map view smoothly by `(dx,dy)` pixels.\n\t * Motion resembles `ease-out`, i.e. slowing down to the end.\n\t * Useful for handling move buttons.\n\t * @param {number} dx\n\t * @param {number} dy\n\t * @param {number} stamp move start time, usually `event.timeStamp` or `performance.now()`\n\t */\n\tthis.moveSmooth = (dx, dy, stamp) => {\n\t\tif (moveAnimationMode !== MOVE_ANIM_MODE_SMOOTH) moveAnimationX = moveAnimationY = 0\n\t\tmoveAnimationX += dx\n\t\tmoveAnimationY += dy\n\t\tmoveAnimationPrevStamp = stamp\n\t\tmoveAnimationMode = MOVE_ANIM_MODE_SMOOTH\n\t\tsmoothIfNecessary(stamp)\n\t}\n\n\t/**\n\t * Start moving map view with a certain speed and a gradual slowdown.\n\t * Useful for mouse/touch handling.\n\t * @param {number} dx horizontal speed in px/ms\n\t * @param {number} dy vertival speed in px/ms\n\t * @param {number} stamp move start time, usually `event.timeStamp` or `performance.now()`\n\t */\n\tthis.applyMoveInertia = (dx, dy, stamp) => {\n\t\tmoveAnimationX = dx\n\t\tmoveAnimationY = dy\n\t\tmoveAnimationPrevStamp = stamp\n\t\tmoveAnimationMode = MOVE_ANIM_MODE_INERTIA\n\t\tsmoothIfNecessary(stamp)\n\t}\n\t/**\n\t * Start zoomin map with a certain speed and a gradual slowdown around `(x,y)` reference point.\n\t * Useful for multitouch pinch-zoom handling.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} delta zoom speed, times per ms.\n\t * @param {number} stamp zoom start time, usually `event.timeStamp` or `performance.now()`\n\t */\n\tthis.applyZoomInertia = (x, y, delta, stamp) => {\n\t\tzoomAnimationDelta = delta\n\t\tzoomAnimationX = x\n\t\tzoomAnimationY = y\n\t\tzoomAnimationPrevStamp = stamp\n\t\tzoomAnimationMode = ZOOM_ANIM_MODE_INERTIA\n\t\tsmoothIfNecessary(stamp)\n\t}\n\n\t//------------\n\t// events\n\t//------------\n\n\t// TODO: if it could be overloaded, `K` may be `keyof MapEventHandlersMap`\n\t//       and editor will provide `name` completions (like with `addEventListener`)\n\t//       https://github.com/microsoft/TypeScript/issues/25590\n\t/**\n\t * Emits a built-in (see {@linkcode MapEventHandlersMap}) or custom event with some arguments.\n\t * @template {string} K\n\t * @param {K} name\n\t * @param {K extends keyof import('./common_types').MapEventHandlersMap\n\t *           ? import('./common_types').MapEventHandlersMap[K]\n\t *           : unknown} params\n\t */\n\tthis.emit = (name, params) => {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = layers[i]\n\t\t\tconst handler = layer.onEvent && layer.onEvent[name]\n\t\t\tif (handler) handler(this, params)\n\t\t}\n\t}\n\n\t//-----------\n\t// setup\n\t//-----------\n\n\tpos_map2screen()\n}\n\n/** @type {ProjectionConverter} */\nexport const ProjectionFlat = {\n\tx2lon(x, zoom) {\n\t\treturn x / zoom\n\t},\n\ty2lat(y, zoom) {\n\t\treturn y / zoom\n\t},\n\n\tlon2x(lon, zoom) {\n\t\treturn lon * zoom\n\t},\n\tlat2y(lat, zoom) {\n\t\treturn lat * zoom\n\t},\n\n\tmeters2pixCoef(lat, zoom) {\n\t\treturn zoom\n\t},\n}\n\n/** @type {ProjectionConverter} */\nexport const ProjectionMercator = {\n\tx2lon(x, z) {\n\t\treturn (x / z) * 360 - 180\n\t},\n\ty2lat(y, z) {\n\t\tconst n = Math.PI - (2 * Math.PI * y) / z\n\t\treturn (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)))\n\t},\n\n\tlon2x(lon, zoom) {\n\t\treturn ((lon + 180) / 360) * zoom\n\t},\n\tlat2y(lat, zoom) {\n\t\treturn (\n\t\t\t((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) /\n\t\t\t\t2) *\n\t\t\tzoom\n\t\t)\n\t},\n\n\tmeters2pixCoef(lat, zoom) {\n\t\tlat *= Math.PI / 180\n\t\treturn zoom / 40075000 / Math.abs(Math.cos(lat))\n\t},\n}\n\n/** @type {ProjectionConverter} */\nexport const ProjectionYandexMercator = {\n\t// http://www.geofaq.ru/forum/index.php?action=vthread&forum=2&topic=7&page=5#msg1152\n\t// http://habrahabr.ru/post/151103/\n\tx2lon(x, zoom) {\n\t\treturn (x / zoom) * 360 - 180\n\t},\n\ty2lat(y, zoom) {\n\t\tconst ty = Math.exp((y / zoom) * Math.PI * 2 - Math.PI)\n\t\tconst m = 5.328478445e-11\n\t\tconst h = 1.764564338702e-8\n\t\tconst k = 0.00000657187271079536\n\t\tconst n = 0.003356551468879694\n\t\tconst g = Math.PI / 2 - 2 * Math.atan(ty)\n\t\t// prettier-ignore\n\t\tconst l = g + n*Math.sin(2*g) + k*Math.sin(4*g) + h*Math.sin(6*g) + m*Math.sin(8*g);\n\t\treturn (l * 180) / Math.PI\n\t},\n\n\tlon2x(lon, zoom) {\n\t\treturn ((lon + 180) / 360) * zoom\n\t},\n\tlat2y(lat, zoom) {\n\t\tconst l = (lat * Math.PI) / 180\n\t\tconst k = 0.0818191908426\n\t\tconst t = k * Math.sin(l)\n\t\t// prettier-ignore\n\t\treturn (\n\t\t\t1 -\n\t\t\tMath.log(\n\t\t\t\tMath.tan(Math.PI/4 + l/2)\n\t\t\t) / Math.PI +\n\t\t\tk*Math.log(\n\t\t\t\tMath.tan(\n\t\t\t\t\tMath.PI/4 +\n\t\t\t\t\tMath.asin(t)/2\n\t\t\t\t)\n\t\t\t) / Math.PI\n\t\t) / 2 * zoom\n\t},\n\n\tmeters2pixCoef(lat, zoom) {\n\t\tlat *= Math.PI / 180\n\t\treturn zoom / 40075000 / Math.abs(Math.cos(lat))\n\t},\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @param {number} val\n * @param {number} delta\n */\nfunction mutlClamp(min, max, val, delta) {\n\tval *= delta\n\tif (delta < 1 && val < min) val = min\n\tif (delta > 1 && val > max) val = max\n\treturn val\n}\n","/** @typedef {[EventTarget, string, (e:any) => void]} Evt */\n/** @typedef {[allEents:Evt[], autoOnEvents:Evt[]]} EvtGroup */\n\n/**\n * @template TElemsCfg\n * @typedef {{\n *   readonly isOn: boolean,\n *   on(elems: TElemsCfg): ControlToggler<TElemsCfg>,\n *   off(): ControlToggler<TElemsCfg>,\n * }} ControlToggler\n */\n\n/**\n * @typedef {{\n *   singleDown?: (e:MouseEvent|TouchEvent, id:'mouse'|number, x:number, y:number) => boolean|void,\n *   singleMove?: (e:MouseEvent|TouchEvent, id:'mouse'|number, x:number, y:number) => void|boolean,\n *   singleUp?:   (e:MouseEvent|TouchEvent, id:'mouse'|number) => void|boolean,\n * }} SingleMoveCallbacks\n */\n\n/**\n * @typedef {{\n *   singleHover?: (e:MouseEvent, x:number, y:number) => void|boolean,\n *   singleLeave?: (e:MouseEvent, x:number, y:number) => void|boolean,\n * }} SingleHoverCallbacks\n */\n\n/**\n * @typedef {{\n *   singleDown?: (e:MouseEvent|TouchEvent, id:'mouse'|number, x:number, y:number, isSwitching:boolean) => boolean|void,\n *   singleMove?: (e:MouseEvent|TouchEvent, id:'mouse'|number, x:number, y:number) => void|boolean,\n *   singleUp?:   (e:MouseEvent|TouchEvent, id:'mouse'|number, isSwitching:boolean) => void|boolean,\n *   doubleDown?: (e:TouchEvent, id0:number, x0:number, y0:number, id1:number, x1:number, y1:number) => void|boolean,\n *   doubleMove?: (e:TouchEvent, id0:number, x0:number, y0:number, id1:number, x1:number, y1:number) => void|boolean,\n *   doubleUp?:   (e:TouchEvent, id0:number, id1:number) => void|boolean,\n * }} DoubleMoveCallbacks\n */\n\n/**\n * @typedef {{\n *   wheelRot?: (e:WheelEvent, deltaX:number, deltaY:number, deltaZ:number, x:number, y:number) => void|boolean,\n * }} WheelCallbacks\n */\n\n/**\n * @typedef {{\n *   startElem: Element,\n *   moveElem?: EventTarget|null,\n *   leaveElem?: EventTarget|null,\n *   offsetElem?: Element|null|'no-offset',\n * }} MoveElemsCfg\n */\n\n/**\n * @typedef {{\n *   startElem: Element,\n *   offsetElem?: Element|null|'no-offset',\n * }} WheelElemsCfg\n */\n\n/**\n * @param {SingleMoveCallbacks & SingleHoverCallbacks} callbacks\n */\nexport function controlSingle(callbacks) {\n\t/** @type {Element} */ let startElem\n\t/** @type {EventTarget} */ let moveElem\n\t/** @type {EventTarget} */ let leaveElem\n\t/** @type {Element|null} */ let offsetElem\n\n\t/** @type {Evt} */ let mouseDownEvt\n\t/** @type {Evt} */ let mouseMoveEvt\n\t/** @type {Evt} */ let mouseUpEvt\n\t/** @type {Evt} */ let mouseHoverEvt\n\t/** @type {Evt} */ let mouseLeaveEvt\n\t/** @type {Evt} */ let touchStartEvt\n\t/** @type {Evt} */ let touchMoveEvt\n\t/** @type {Evt} */ let touchEndEvt\n\t/** @type {Evt} */ let touchCancelEvt\n\n\tconst { singleDown = noop, singleMove = noop, singleUp = noop } = callbacks\n\tconst { singleHover = noop, singleLeave = noop } = callbacks\n\n\tlet touchId = /** @type {number|null} */ (null)\n\n\tconst wrap = makeOffsetWrapper(() => offsetElem)\n\n\tconst mousedown = wrap(function mousedown(/** @type {MouseEvent} */ e, dx, dy) {\n\t\tif (e.button !== 0) return false\n\t\taddListener(mouseMoveEvt)\n\t\taddListener(mouseUpEvt)\n\t\tremoveListener(mouseHoverEvt)\n\t\treturn singleDown(e, 'mouse', e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst mousemove = wrap(function mousemove(/** @type {MouseEvent} */ e, dx, dy) {\n\t\treturn singleMove(e, 'mouse', e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst mouseup = wrap(function mouseup(/** @type {MouseEvent} */ e, dx, dy) {\n\t\tif (e.button !== 0) return false\n\t\tremoveListener(mouseMoveEvt)\n\t\tremoveListener(mouseUpEvt)\n\t\taddListener(mouseHoverEvt)\n\t\treturn singleUp(e, 'mouse')\n\t})\n\n\tconst mousemoveHover = wrap(function mousemoveHover(/** @type {MouseEvent} */ e, dx, dy) {\n\t\treturn singleHover(e, e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst mouseleave = wrap(function mouseleave(/** @type {MouseEvent} */ e, dx, dy) {\n\t\treturn singleLeave(e, e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst touchstart = wrap(function touchstart(/** @type {TouchEvent} */ e, dx, dy) {\n\t\tif (touchId !== null) return false\n\n\t\taddListener(touchMoveEvt)\n\t\taddListener(touchEndEvt)\n\t\taddListener(touchCancelEvt)\n\n\t\tconst t = e.changedTouches[0]\n\t\ttouchId = t.identifier\n\t\treturn singleDown(e, touchId, t.clientX + dx, t.clientY + dy)\n\t})\n\n\tconst touchmove = wrap(function touchmove(/** @type {TouchEvent} */ e, dx, dy) {\n\t\tif (touchId === null) return false\n\t\tconst touch = findTouch(e.changedTouches, touchId)\n\t\tif (touch === null) return false\n\t\treturn singleMove(e, touchId, touch.clientX + dx, touch.clientY + dy)\n\t})\n\n\tconst touchend = wrap(function touchend(/** @type {TouchEvent} */ e, dx, dy) {\n\t\tif (touchId === null) return false\n\n\t\tconst releasedTouch = findTouch(e.changedTouches, touchId)\n\t\tif (releasedTouch === null) return false\n\n\t\ttouchId = null\n\n\t\tremoveListener(touchMoveEvt)\n\t\tremoveListener(touchEndEvt)\n\t\tremoveListener(touchCancelEvt)\n\n\t\treturn singleUp(e, releasedTouch.identifier)\n\t})\n\n\tconst touchcancel = wrap(function touchcancel(/** @type {TouchEvent} */ e, dx, dy) {\n\t\ttouchend(e)\n\t})\n\n\treturn makeEventsToggler((/**@type {MoveElemsCfg}*/ elems) => {\n\t\tstartElem = elems.startElem\n\t\tmoveElem = elems.moveElem ?? window\n\t\tleaveElem = elems.leaveElem ?? startElem\n\t\toffsetElem = nullUnlessOffset(elems.offsetElem, startElem)\n\n\t\tmouseDownEvt = /** @type {Evt} */ ([startElem, 'mousedown', mousedown])\n\t\tmouseMoveEvt = /** @type {Evt} */ ([moveElem, 'mousemove', mousemove])\n\t\tmouseUpEvt = /** @type {Evt} */ ([moveElem, 'mouseup', mouseup])\n\t\tmouseHoverEvt = /** @type {Evt} */ ([moveElem, 'mousemove', mousemoveHover])\n\t\tmouseLeaveEvt = /** @type {Evt} */ ([leaveElem, 'mouseleave', mouseleave])\n\t\ttouchStartEvt = /** @type {Evt} */ ([startElem, 'touchstart', touchstart])\n\t\ttouchMoveEvt = /** @type {Evt} */ ([moveElem, 'touchmove', touchmove])\n\t\ttouchEndEvt = /** @type {Evt} */ ([moveElem, 'touchend', touchend])\n\t\ttouchCancelEvt = /** @type {Evt} */ ([moveElem, 'touchcancel', touchcancel])\n\n\t\t// prettier-ignore\n\t\tconst events = [\n\t\t\tmouseDownEvt, mouseMoveEvt, mouseUpEvt, mouseHoverEvt, mouseLeaveEvt,\n\t\t\ttouchStartEvt, touchMoveEvt, touchEndEvt, touchCancelEvt,\n\t\t]\n\t\tconst autoOnEvents = [mouseDownEvt, touchStartEvt, mouseHoverEvt, mouseLeaveEvt]\n\t\treturn [events, autoOnEvents]\n\t})\n}\n\n/**\n * @param {WheelCallbacks} callbacks\n */\nexport function controlWheel(callbacks) {\n\tconst wheelRot = callbacks.wheelRot ?? noop\n\n\t/** @type {Element|null} */ let offsetElem\n\n\tconst wrap = makeOffsetWrapper(() => offsetElem)\n\tconst mousewheel = makeWheelListener(wrap, wheelRot)\n\n\treturn makeEventsToggler((/**@type {WheelElemsCfg}*/ elems) => {\n\t\tconst startElem = elems.startElem\n\t\toffsetElem = nullUnlessOffset(elems.offsetElem, startElem)\n\n\t\tconst wheelEvt = /** @type {Evt} */ ([startElem, 'wheel', mousewheel])\n\n\t\treturn [[wheelEvt], [wheelEvt]]\n\t})\n}\n\n/**\n * @param {DoubleMoveCallbacks & SingleHoverCallbacks & WheelCallbacks} callbacks\n */\nexport function controlDouble(callbacks) {\n\t/** @type {Element} */ let startElem\n\t/** @type {EventTarget} */ let moveElem\n\t/** @type {EventTarget} */ let leaveElem\n\t/** @type {Element|null} */ let offsetElem\n\n\t/** @type {Evt} */ let mouseDownEvt\n\t/** @type {Evt} */ let mouseMoveEvt\n\t/** @type {Evt} */ let mouseUpEvt\n\t/** @type {Evt} */ let wheelEvt\n\t/** @type {Evt} */ let mouseHoverEvt\n\t/** @type {Evt} */ let mouseLeaveEvt\n\t/** @type {Evt} */ let touchStartEvt\n\t/** @type {Evt} */ let touchMoveEvt\n\t/** @type {Evt} */ let touchEndEvt\n\t/** @type {Evt} */ let touchCancelEvt\n\n\tconst { singleDown = noop, singleMove = noop, singleUp = noop } = callbacks\n\tconst { doubleDown = noop, doubleMove = noop, doubleUp = noop } = callbacks\n\tconst { singleHover = noop, singleLeave = noop, wheelRot = noop } = callbacks\n\n\tconst touchIds = /** @type {number[]} */ ([])\n\n\tconst wrap = makeOffsetWrapper(() => offsetElem)\n\n\tconst mousedown = wrap(function mousedown(/** @type {MouseEvent} */ e, dx, dy) {\n\t\tif (e.button !== 0) return false\n\t\taddListener(mouseMoveEvt)\n\t\taddListener(mouseUpEvt)\n\t\tremoveListener(mouseHoverEvt)\n\t\treturn singleDown(e, 'mouse', e.clientX + dx, e.clientY + dy, false)\n\t})\n\n\tconst mousemove = wrap(function mousemove(/** @type {MouseEvent} */ e, dx, dy) {\n\t\treturn singleMove(e, 'mouse', e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst mouseup = wrap(function mouseup(/** @type {MouseEvent} */ e, dx, dy) {\n\t\tif (e.button !== 0) return false\n\t\tremoveListener(mouseMoveEvt)\n\t\tremoveListener(mouseUpEvt)\n\t\taddListener(mouseHoverEvt)\n\t\treturn singleUp(e, 'mouse', false)\n\t})\n\n\tconst mousemoveHover = wrap(function mousemoveHover(/** @type {MouseEvent} */ e, dx, dy) {\n\t\treturn singleHover(e, e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst mouseleave = wrap(function mouseleave(/** @type {MouseEvent} */ e, dx, dy) {\n\t\treturn singleLeave(e, e.clientX + dx, e.clientY + dy)\n\t})\n\n\tconst touchstart = wrap(function touchstart(/** @type {TouchEvent} */ e, dx, dy) {\n\t\tconst curCount = touchIds.length\n\t\tif (curCount === 2) return false\n\t\tconst changedTouches = e.changedTouches\n\n\t\tif (curCount === 0) {\n\t\t\taddListener(touchMoveEvt)\n\t\t\taddListener(touchEndEvt)\n\t\t\taddListener(touchCancelEvt)\n\t\t}\n\n\t\tif (curCount === 0 && changedTouches.length === 1) {\n\t\t\tconst t = e.changedTouches[0]\n\t\t\ttouchIds.push(t.identifier)\n\t\t\treturn singleDown(e, touchIds[0], t.clientX + dx, t.clientY + dy, false)\n\t\t}\n\n\t\tlet t0, t1\n\t\tlet prevent = /**@type {void|boolean}*/ (false)\n\t\tif (curCount === 0) {\n\t\t\t// and changedTouches.length >= 2\n\t\t\tt0 = changedTouches[0]\n\t\t\tt1 = changedTouches[1]\n\t\t\ttouchIds.push(t0.identifier)\n\t\t\tprevent = singleDown(e, t0.identifier, t0.clientX + dx, t0.clientY + dy, false)\n\t\t} else {\n\t\t\t// curCount === 1 and changedTouches.length >= 1\n\t\t\tt0 = mustFindTouch(e.touches, touchIds[0])\n\t\t\tt1 = e.changedTouches[0]\n\t\t}\n\t\ttouchIds.push(t1.identifier)\n\t\tconst prevetUp = singleUp(e, t0.identifier, true)\n\t\tprevent = prevent || prevetUp\n\n\t\tconst x0 = t0.clientX + dx\n\t\tconst y0 = t0.clientY + dy\n\t\tconst x1 = t1.clientX + dx\n\t\tconst y1 = t1.clientY + dy\n\t\tconst preventDouble = doubleDown(e, touchIds[0], x0, y0, touchIds[1], x1, y1)\n\t\treturn prevent || preventDouble\n\t})\n\n\tconst touchmove = wrap(function touchmove(/** @type {TouchEvent} */ e, dx, dy) {\n\t\tconst curCount = touchIds.length\n\t\tif (curCount === 1) {\n\t\t\tconst t0 = findTouch(e.changedTouches, touchIds[0])\n\t\t\tif (t0 === null) return false\n\t\t\treturn singleMove(e, touchIds[0], t0.clientX + dx, t0.clientY + dy)\n\t\t}\n\t\tif (curCount === 2) {\n\t\t\t// can not use e.changedTouches: one of touches may have not changed\n\t\t\tconst t0 = mustFindTouch(e.touches, touchIds[0])\n\t\t\tconst t1 = mustFindTouch(e.touches, touchIds[1])\n\t\t\tconst x0 = t0.clientX + dx\n\t\t\tconst y0 = t0.clientY + dy\n\t\t\tconst x1 = t1.clientX + dx\n\t\t\tconst y1 = t1.clientY + dy\n\t\t\treturn doubleMove(e, touchIds[0], x0, y0, touchIds[1], x1, y1)\n\t\t}\n\t})\n\n\tconst releasedTouches = /** @type {Touch[]} */ ([])\n\tconst touchend = wrap(function touchend(/** @type {TouchEvent} */ e, dx, dy) {\n\t\tconst curCount = touchIds.length\n\t\tif (curCount === 0) return false\n\n\t\tconst tid0 = touchIds[0]\n\t\tconst tid1 = touchIds[1]\n\n\t\treleasedTouches.length = 0\n\t\tfor (let j = touchIds.length - 1; j >= 0; j--) {\n\t\t\tfor (let i = 0; i < e.changedTouches.length; i++) {\n\t\t\t\tconst t = e.changedTouches[i]\n\t\t\t\tif (t.identifier === touchIds[j]) {\n\t\t\t\t\ttouchIds.splice(j, 1)\n\t\t\t\t\treleasedTouches.push(t)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (releasedTouches.length === 0) return false\n\n\t\tif (curCount === releasedTouches.length) {\n\t\t\tremoveListener(touchMoveEvt)\n\t\t\tremoveListener(touchEndEvt)\n\t\t\tremoveListener(touchCancelEvt)\n\t\t}\n\n\t\tif (curCount === 1) {\n\t\t\t// and releasedTouches.length === 1\n\t\t\treturn singleUp(e, releasedTouches[0].identifier, false)\n\t\t}\n\n\t\t// curCount === 2 and releasedTouches.length >= 1\n\t\tconst tLast =\n\t\t\treleasedTouches.length === 1 ? mustFindTouch(e.touches, touchIds[0]) : releasedTouches[1]\n\n\t\tconst preventUp2 = doubleUp(e, tid0, tid1)\n\t\tconst preventDown1 = singleDown(e, tLast.identifier, tLast.clientX + dx, tLast.clientY + dy, true)\n\t\tlet preventUp1 = /**@type {void|boolean}*/ (false)\n\t\tif (curCount === 2 && releasedTouches.length === 2) {\n\t\t\tpreventUp1 = singleUp(e, tLast.identifier, false)\n\t\t}\n\t\treturn preventUp2 || preventDown1 || preventUp1\n\t})\n\n\tconst touchcancel = wrap(function touchcancel(/** @type {TouchEvent} */ e, dx, dy) {\n\t\ttouchend(e)\n\t})\n\n\tconst mousewheel = makeWheelListener(wrap, wheelRot)\n\n\treturn makeEventsToggler((/**@type {MoveElemsCfg}*/ elems) => {\n\t\tstartElem = elems.startElem\n\t\tmoveElem = elems.moveElem ?? window\n\t\tleaveElem = elems.leaveElem ?? startElem\n\t\toffsetElem = nullUnlessOffset(elems.offsetElem, startElem)\n\n\t\tmouseDownEvt = /** @type {Evt} */ ([startElem, 'mousedown', mousedown])\n\t\tmouseMoveEvt = /** @type {Evt} */ ([moveElem, 'mousemove', mousemove])\n\t\tmouseUpEvt = /** @type {Evt} */ ([moveElem, 'mouseup', mouseup])\n\t\twheelEvt = /** @type {Evt} */ ([startElem, 'wheel', mousewheel])\n\t\tmouseHoverEvt = /** @type {Evt} */ ([moveElem, 'mousemove', mousemoveHover])\n\t\tmouseLeaveEvt = /** @type {Evt} */ ([leaveElem, 'mouseleave', mouseleave])\n\t\ttouchStartEvt = /** @type {Evt} */ ([startElem, 'touchstart', touchstart])\n\t\ttouchMoveEvt = /** @type {Evt} */ ([moveElem, 'touchmove', touchmove])\n\t\ttouchEndEvt = /** @type {Evt} */ ([moveElem, 'touchend', touchend])\n\t\ttouchCancelEvt = /** @type {Evt} */ ([moveElem, 'touchcancel', touchcancel])\n\n\t\t// prettier-ignore\n\t\tconst events = [\n\t\t\tmouseDownEvt, mouseMoveEvt, mouseUpEvt, mouseHoverEvt, mouseLeaveEvt, wheelEvt,\n\t\t\ttouchStartEvt, touchMoveEvt, touchEndEvt, touchCancelEvt,\n\t\t]\n\t\tconst autoOnEvents = [mouseDownEvt, touchStartEvt, mouseHoverEvt, mouseLeaveEvt, wheelEvt]\n\t\treturn [events, autoOnEvents]\n\t})\n}\n\nfunction noop() {}\n\n/**\n * @param {() => Element|null|undefined} getOffsetElem\n */\nfunction makeOffsetWrapper(getOffsetElem) {\n\t/**\n\t * @template {Event} T\n\t * @param {(e:T, x:number, y:number) => boolean|void} func\n\t * @returns {(e:T) => void}\n\t */\n\tfunction wrap(func) {\n\t\treturn e => {\n\t\t\tlet dx = 0\n\t\t\tlet dy = 0\n\t\t\tconst elem = getOffsetElem()\n\t\t\tif (elem) ({ left: dx, top: dy } = elem.getBoundingClientRect())\n\t\t\tfunc(e, -dx, -dy) && e.preventDefault()\n\t\t}\n\t}\n\treturn wrap\n}\n\n/**\n * @param {Element|null|undefined|'no-offset'} elem\n * @param {Element} defaultElem\n */\nfunction nullUnlessOffset(elem, defaultElem) {\n\tif (elem === 'no-offset') return null\n\treturn elem ?? defaultElem\n}\n\n/**\n * @param {(func: (e:WheelEvent, x:number, y:number) => boolean|void) => ((e:WheelEvent) => void)} wrap\n * @param {(e:WheelEvent, deltaX:number, deltaY:number, deltaZ:number, x:number, y:number) => void|boolean} wheelRot\n */\nfunction makeWheelListener(wrap, wheelRot) {\n\tconst deltaMode2pixels = []\n\tdeltaMode2pixels[WheelEvent.DOM_DELTA_PIXEL] = 1\n\tdeltaMode2pixels[WheelEvent.DOM_DELTA_LINE] = 20\n\tdeltaMode2pixels[WheelEvent.DOM_DELTA_PAGE] = 50 // а это вообще как?\n\treturn wrap(function mousewheel(/** @type {WheelEvent} */ e, dx, dy) {\n\t\tconst k = deltaMode2pixels[e.deltaMode]\n\t\treturn wheelRot(e, e.deltaX * k, e.deltaY * k, e.deltaZ * k, e.clientX + dx, e.clientY + dy)\n\t})\n}\n\n/**\n * @template TElemsCfg\n * @param {(elems: TElemsCfg) => EvtGroup} getEvents\n * @returns {ControlToggler<TElemsCfg>}\n */\nfunction makeEventsToggler(getEvents) {\n\tlet events = /**@type {(EvtGroup|null)}*/ (null)\n\n\treturn {\n\t\tget isOn() {\n\t\t\treturn !!events\n\t\t},\n\t\ton(elems) {\n\t\t\tif (!events) {\n\t\t\t\tevents = getEvents(elems)\n\t\t\t\tconst autoOnEvents = events[1]\n\t\t\t\tautoOnEvents.map(addListener)\n\t\t\t}\n\t\t\treturn this\n\t\t},\n\t\toff() {\n\t\t\tif (events) {\n\t\t\t\tconst allEents = events[0]\n\t\t\t\tallEents.map(removeListener)\n\t\t\t\tevents = null\n\t\t\t}\n\t\t\treturn this\n\t\t},\n\t}\n}\n\n/**\n * @param {TouchList} list\n * @param {number} id\n */\nfunction findTouch(list, id) {\n\tfor (let i = 0; i < list.length; i++) if (list[i].identifier === id) return list[i]\n\treturn null\n}\n/**\n * @param {TouchList} list\n * @param {number} id\n */\nfunction mustFindTouch(list, id) {\n\tconst touch = findTouch(list, id)\n\tif (touch === null) throw new Error(`touch #${id} not found`)\n\treturn touch\n}\n\n/** @param {Evt} event */\nfunction addListener(event) {\n\tevent[0].addEventListener(event[1], event[2], { capture: true, passive: false })\n}\n\n/** @param {Evt} event */\nfunction removeListener(event) {\n\tevent[0].removeEventListener(event[1], event[2], { capture: true })\n}\n","import { controlDouble } from 'js-control'\nimport { applyStyles, clamp } from './utils.js'\n\n/**\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n */\nfunction point_distance(x1, y1, x2, y2) {\n\treturn Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))\n}\n\n/**\n * Returns `attr` speed prediction for `timeStamp` moment by\n * calculating acceleration of values `items[i][attr]` (with linear approximation).\n * @param {{stamp:number}[]} items\n * @param {string} attr\n * @param {number} timeStamp\n */\nfunction getApproximatedSpeed(items, attr, timeStamp) {\n\t// https://prog-cpp.ru/mnk/\n\tlet sumx = 0\n\tlet sumy = 0\n\tlet sumx2 = 0\n\tlet sumxy = 0\n\tlet n = 0\n\tconst len = items.length\n\tconst now = performance.now()\n\tconst last = items[len - 1]\n\tlet cur = last\n\tfor (let i = len - 1; i > 0; i--) {\n\t\tconst prev = items[i - 1]\n\t\tif (now - prev.stamp > 150) break\n\t\tconst dtime = cur.stamp - prev.stamp\n\t\tconst dattr = cur[attr] - prev[attr]\n\t\tif (dtime === 0) continue\n\n\t\tconst x = cur.stamp\n\t\tconst y = /**@type {number}*/ (dattr / dtime)\n\t\tsumx += x\n\t\tsumy += y\n\t\tsumx2 += x * x\n\t\tsumxy += x * y\n\t\tn++\n\t\tcur = prev\n\t}\n\n\tif (n === 1) {\n\t\t// Got only two usable items (the last movement was too short),\n\t\t// just returning average speed between them.\n\t\tconst dtime = last.stamp - cur.stamp\n\t\tconst dattr = last[attr] - cur[attr]\n\t\tif (dtime < 4) return 0 //in case events are too close or have the same time\n\t\treturn dattr / dtime\n\t}\n\tif (n === 0) return 0\n\n\tconst aDenom = n * sumx2 - sumx * sumx\n\tif (aDenom === 0) return 0\n\tconst a = (n * sumxy - sumx * sumy) / aDenom\n\tconst b = (sumy - a * sumx) / n\n\tlet k = a * timeStamp + b\n\n\tconst dattr = last[attr] - cur[attr]\n\tif (k * dattr < 0) k = 0 //if acceleration changes the sign (i.e. flips direction), movement should be stopped\n\treturn k\n}\n\n/**\n * \"default timing in Windows is 500ms\" https://stackoverflow.com/a/29917394\n */\nexport const DBL_CLICK_MAX_DELAY = 500\n\n/**\n * Enables mouse and touch input: gragging, wheel- and pinch-zooming.\n * @class\n * @param {{doNotInterfere?:boolean}} [opts]\n */\nexport function PointerControlLayer(opts) {\n\tconst { doNotInterfere } = opts || {}\n\t/** @type {{off():unknown}} */\n\tlet control\n\n\tlet mouseX = 0\n\tlet mouseY = 0\n\n\tlet moveDistance = 0\n\tlet lastSingleClickAt = 0\n\tlet lastDoubleTouchParams = /**@type {[number,number,number,number,number,number]|null}*/ (null)\n\n\tlet lastDoubleTouch_cx = 0\n\tlet lastDoubleTouch_cy = 0\n\tlet lastDoubleTouch_dx = 0\n\tlet lastDoubleTouch_dy = 0\n\tlet lastDoubleTouch_dist = 1\n\tlet lastDoubleTouch_stamp = 0\n\n\tlet lastMoves = [{ x: 0, y: 0, stamp: 0 }]\n\tlet lastZooms = [{ dist: 0, stamp: 0 }]\n\tfor (const arr of [lastMoves, lastZooms])\n\t\twhile (arr.length < 5) arr.push(Object.assign({}, /**@type {*}*/ (arr[0])))\n\n\t/**\n\t * If stamp is new, pops the first array element, pushes in back and returns it.\n\t * If stamp is same, just returns the last array element.\n\t * Useful for Safari (and maybe some others) where sometimes a bunch of touch events\n\t * come with same timeStamp. In that case we should just update last element, not push anything.\n\t * @template {{stamp:number}} T\n\t * @param {T[]} arr\n\t * @param {number} stamp\n\t * @returns {T}\n\t */\n\tfunction peekOrShift(arr, stamp) {\n\t\tconst last = arr[arr.length - 1]\n\t\tif (last.stamp === stamp) return last\n\t\tconst newLast = /** @type {*} */ (arr.shift())\n\t\tarr.push(newLast)\n\t\treturn newLast\n\t}\n\t/** @param {number} stamp */\n\tfunction recordMousePos(stamp) {\n\t\tconst last = peekOrShift(lastMoves, stamp)\n\t\tlast.x = mouseX\n\t\tlast.y = mouseY\n\t\tlast.stamp = stamp\n\t}\n\t/** Shifts all lastMoves so that the last recorded move will be at mouse(x,y) */\n\tfunction moveRecordedMousePos() {\n\t\tconst last = lastMoves[lastMoves.length - 1]\n\t\tconst dx = mouseX - last.x\n\t\tconst dy = mouseY - last.y\n\t\tfor (let i = 0; i < lastMoves.length; i++) {\n\t\t\tlastMoves[i].x += dx\n\t\t\tlastMoves[i].y += dy\n\t\t}\n\t}\n\t/** @param {number} stamp */\n\tfunction recordTouchDist(stamp) {\n\t\tconst last = peekOrShift(lastZooms, stamp)\n\t\tlast.dist = lastDoubleTouch_dist\n\t\tlast.stamp = stamp\n\t}\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} eventTimeStamp\n\t */\n\tfunction applyInertia(map, eventTimeStamp) {\n\t\tconst dx = getApproximatedSpeed(lastMoves, 'x', eventTimeStamp)\n\t\tconst dy = getApproximatedSpeed(lastMoves, 'y', eventTimeStamp)\n\t\tconst dz = getApproximatedSpeed(lastZooms, 'dist', eventTimeStamp) / lastDoubleTouch_dist + 1\n\t\t// Each event has two timeStamps:\n\t\t//   1) time of actual user action - event.timeStamp\n\t\t//   2) time of callback call - approx. performance.now()\n\t\t// Delay between them is unstable and different from time to time\n\t\t// and from browser to browser (I've seen 1-16ms delay in Chrome and 1-30ms in FF).\n\t\t// Motion calcuations are done by (1) for the precision sake\n\t\t// but control reactions (redraw after movement) are preformed at callback call time, i.e. (2).\n\t\t// So here movement estimations are calculated for the event (touchup/mouseup) time,\n\t\t// but this inertia movement is *applied* at current time.\n\t\t// If inertia was applied at event time too, there would be sometimes a small movement \"jump\"\n\t\t// after releasing map with motion.\n\t\tmap.applyMoveInertia(dx, dy, performance.now())\n\t\tmap.applyZoomInertia(mouseX, mouseY, dz, performance.now())\n\t}\n\n\t/**\n\t * Sets mouse(x,y) to (x,y) with special post-double-touch correction.\n\t *\n\t * Two fingers do not lift simultaneously, so there is (almost) always two-touches -> one-touch -> no touch.\n\t * This may cause a problem if two touches move in opposite directions (zooming):\n\t * while they both are down, there is a little movement,\n\t * but when first touch lift, second (still down) starts to move map aside with significant speed.\n\t * Then second touch lifts too and speed reduces again (because of smoothing and inertia).\n\t * All that makes motion at the end of zoom gesture looks trembling.\n\t *\n\t * This function tries to fix that by continuing double-touch motion for a while.\n\t * Used only for movement: zooming should remain smooth thanks to applyInertia() at the end of doubleUp().\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} stamp\n\t */\n\tfunction setCorrectedSinglePos(x, y, stamp) {\n\t\tconst timeDelta = stamp - lastDoubleTouch_stamp\n\t\tconst duration = 150\n\t\tconst k = clamp(0, 1, ((duration - timeDelta) / duration) * 2)\n\t\tmouseX = (lastDoubleTouch_cx + lastDoubleTouch_dx * timeDelta) * k + x * (1 - k)\n\t\tmouseY = (lastDoubleTouch_cy + lastDoubleTouch_dy * timeDelta) * k + y * (1 - k)\n\t}\n\n\t/**\n\t * For some reason FF return same touchMove event for each touch\n\t * (two events with same timeStamps and coords for two touches, thee for thee, etc.)\n\t * @param {number} centerX\n\t * @param {number} centerY\n\t * @param {number} distance\n\t * @param {number} stamp\n\t */\n\tfunction doubleMoveHasChanged(centerX, centerY, distance, stamp) {\n\t\treturn (\n\t\t\tmouseX !== centerX ||\n\t\t\tmouseY !== centerY ||\n\t\t\tlastDoubleTouch_dist !== distance ||\n\t\t\tlastMoves[lastMoves.length - 1].stamp !== stamp\n\t\t)\n\t}\n\n\t/**\n\t * @param {MouseEvent|TouchEvent} e\n\t * @param {'mouse'|number} id\n\t */\n\tfunction shouldShowTwoFingersHint(e, id) {\n\t\treturn doNotInterfere && id !== 'mouse' && e.timeStamp - lastDoubleTouch_stamp > 1000\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tconst makeControl = map => {\n\t\tconst canvas = map.getCanvas()\n\t\tcanvas.style.cursor = 'grab'\n\n\t\treturn controlDouble({\n\t\t\tsingleDown(e, id, x, y, isSwitching) {\n\t\t\t\tif (shouldShowTwoFingersHint(e, id)) return false\n\t\t\t\tmap.getWrap().focus()\n\t\t\t\tsetCorrectedSinglePos(x, y, e.timeStamp)\n\t\t\t\tif (isSwitching) moveRecordedMousePos()\n\t\t\t\tif (!isSwitching) {\n\t\t\t\t\trecordMousePos(e.timeStamp)\n\t\t\t\t\tmap.applyMoveInertia(0, 0, e.timeStamp)\n\t\t\t\t\tmap.applyZoomInertia(0, 0, 1, e.timeStamp)\n\t\t\t\t\tmoveDistance = 0\n\t\t\t\t\tlastDoubleTouchParams = null\n\t\t\t\t}\n\t\t\t\tmap.emit('singleDown', { x, y, id, isSwitching })\n\t\t\t\tcanvas.style.cursor = 'grabbing'\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tsingleMove(e, id, x, y) {\n\t\t\t\tif (shouldShowTwoFingersHint(e, id)) {\n\t\t\t\t\tmap.emit('controlHint', { type: 'use_two_fingers' })\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tconst oldX = mouseX\n\t\t\t\tconst oldY = mouseY\n\t\t\t\tsetCorrectedSinglePos(x, y, e.timeStamp)\n\t\t\t\tmoveDistance += point_distance(oldX, oldY, mouseX, mouseY)\n\t\t\t\tmap.move(mouseX - oldX, mouseY - oldY)\n\t\t\t\trecordMousePos(e.timeStamp)\n\t\t\t\tmap.emit('singleMove', { x, y, id })\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tsingleUp(e, id, isSwitching) {\n\t\t\t\tconst stamp = e.timeStamp\n\t\t\t\tif (!isSwitching) applyInertia(map, stamp)\n\t\t\t\tmap.emit('singleUp', { x: mouseX, y: mouseY, id, isSwitching })\n\t\t\t\tif (moveDistance < 5 && !isSwitching) {\n\t\t\t\t\tif (lastDoubleTouchParams) {\n\t\t\t\t\t\tmap.zoomSmooth(mouseX, mouseY, 0.5, stamp)\n\t\t\t\t\t\tconst [id0, x0, y0, id1, x1, y1] = lastDoubleTouchParams\n\t\t\t\t\t\tmap.emit('doubleClick', { id0, x0, y0, id1, x1, y1 })\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst isDbl = lastSingleClickAt > stamp - DBL_CLICK_MAX_DELAY\n\t\t\t\t\t\tlastSingleClickAt = stamp\n\t\t\t\t\t\tif (isDbl) map.zoomSmooth(mouseX, mouseY, 2, stamp)\n\t\t\t\t\t\tmap.emit(isDbl ? 'dblClick' : 'singleClick', { x: mouseX, y: mouseY, id })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcanvas.style.cursor = 'grab'\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tdoubleDown(e, id0, x0, y0, id1, x1, y1) {\n\t\t\t\tmouseX = (x0 + x1) * 0.5\n\t\t\t\tmouseY = (y0 + y1) * 0.5\n\t\t\t\tlastDoubleTouch_dist = point_distance(x0, y0, x1, y1)\n\t\t\t\tlastDoubleTouch_cx = mouseX\n\t\t\t\tlastDoubleTouch_cy = mouseY\n\t\t\t\tmoveRecordedMousePos()\n\t\t\t\tlastDoubleTouchParams = [id0, x0, y0, id1, x1, y1]\n\t\t\t\tmap.emit('doubleDown', { id0, x0, y0, id1, x1, y1 })\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tdoubleMove(e, id0, x0, y0, id1, x1, y1) {\n\t\t\t\tconst cx = (x0 + x1) * 0.5\n\t\t\t\tconst cy = (y0 + y1) * 0.5\n\t\t\t\tconst cd = point_distance(x0, y0, x1, y1)\n\t\t\t\tif (doubleMoveHasChanged(cx, cy, cd, e.timeStamp)) {\n\t\t\t\t\tmap.move(cx - mouseX, cy - mouseY)\n\t\t\t\t\tmap.zoom(cx, cy, cd / lastDoubleTouch_dist)\n\t\t\t\t\tmoveDistance +=\n\t\t\t\t\t\tpoint_distance(mouseX, mouseY, cx, cy) + Math.abs(cd - lastDoubleTouch_dist)\n\t\t\t\t\tlastDoubleTouchParams = [id0, x0, y0, id1, x1, y1]\n\t\t\t\t\tmouseX = cx\n\t\t\t\t\tmouseY = cy\n\t\t\t\t\tlastDoubleTouch_dist = cd\n\t\t\t\t\tlastDoubleTouch_cx = cx\n\t\t\t\t\tlastDoubleTouch_cy = cy\n\t\t\t\t\trecordMousePos(e.timeStamp)\n\t\t\t\t\trecordTouchDist(e.timeStamp)\n\t\t\t\t\tmap.emit('doubleMove', { id0, x0, y0, id1, x1, y1 })\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tdoubleUp(e, id0, id1) {\n\t\t\t\tconst stamp = e.timeStamp\n\t\t\t\tlastDoubleTouch_dx = getApproximatedSpeed(lastMoves, 'x', stamp)\n\t\t\t\tlastDoubleTouch_dy = getApproximatedSpeed(lastMoves, 'y', stamp)\n\t\t\t\tlastDoubleTouch_stamp = e.timeStamp\n\t\t\t\tmap.emit('doubleUp', { id0, id1 })\n\t\t\t\treturn true\n\t\t\t},\n\t\t\twheelRot(e, deltaX, deltaY, deltaZ, x, y) {\n\t\t\t\tif (!doNotInterfere || e.ctrlKey || e.metaKey) {\n\t\t\t\t\tmap.zoomSmooth(x, y, Math.pow(2, -deltaY / 240), e.timeStamp)\n\t\t\t\t\treturn true\n\t\t\t\t} else {\n\t\t\t\t\tmap.emit('controlHint', { type: 'use_control_to_zoom' })\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t},\n\t\t\tsingleHover(e, x, y) {\n\t\t\t\tmap.emit('singleHover', { x, y })\n\t\t\t},\n\t\t}).on({\n\t\t\t// not map.getWrap(): so this layer will not prevent events from reaching other layers\n\t\t\tstartElem: canvas,\n\t\t})\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.register = map => {\n\t\tcontrol = makeControl(map)\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.unregister = map => {\n\t\tcontrol.off()\n\t}\n}\n\n/**\n * Enables keyboard controls: arrows for movement, +/- for zoom. Shift can be used for speedup.\n * Makes map element focusable.\n * @class\n * @param {object} [opts]\n * @param {string|null} [opts.outlineFix] value that will be set to `map.getWrap().style.outline`.\n *   It's a workaround for mobile Safari 14 (at least) bug where `canvas` performance\n *   drops significantly after changing parent `tabIndex` attribute.\n *   'none' (default) seems fixing the issue.\n */\nexport function KeyboardControlLayer(opts) {\n\tconst { outlineFix = 'none' } = opts || {}\n\t/** @type {(e:KeyboardEvent) => unknown} */\n\tlet handler\n\tlet oldTabIndex = -1\n\n\t/** @param {import('./map').LocMap} map */\n\tconst makeHandler = map => (/**@type {KeyboardEvent}*/ e) => {\n\t\tif (e.ctrlKey || e.altKey) return\n\n\t\tlet shouldPrevent = true\n\t\tconst { key, shiftKey, timeStamp } = e\n\t\tconst [width, height] = map.getViewBoxSize()\n\t\tconst moveDelta = 75 * (shiftKey ? 3 : 1)\n\t\tconst zoomDelta = 2 * (shiftKey ? 2 : 1)\n\n\t\tif (key === 'ArrowUp') {\n\t\t\tmap.moveSmooth(0, moveDelta, timeStamp)\n\t\t} else if (key === 'ArrowDown') {\n\t\t\tmap.moveSmooth(0, -moveDelta, timeStamp)\n\t\t} else if (key === 'ArrowLeft') {\n\t\t\tmap.moveSmooth(moveDelta, 0, timeStamp)\n\t\t} else if (key === 'ArrowRight') {\n\t\t\tmap.moveSmooth(-moveDelta, 0, timeStamp)\n\t\t} else if (key === '=' || key === '+') {\n\t\t\tmap.zoomSmooth(width / 2, height / 2, zoomDelta, timeStamp)\n\t\t} else if (key === '-' || key === '_') {\n\t\t\tmap.zoomSmooth(width / 2, height / 2, 1 / zoomDelta, timeStamp)\n\t\t} else {\n\t\t\tshouldPrevent = false\n\t\t}\n\n\t\tif (shouldPrevent) e.preventDefault()\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.register = map => {\n\t\tconst wrap = map.getWrap()\n\t\toldTabIndex = wrap.tabIndex\n\t\twrap.tabIndex = 1\n\t\tif (outlineFix !== null) wrap.style.outline = outlineFix\n\t\thandler = makeHandler(map)\n\t\twrap.addEventListener('keydown', handler)\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.unregister = map => {\n\t\tconst wrap = map.getWrap()\n\t\twrap.tabIndex = oldTabIndex\n\t\twrap.removeEventListener('keydown', handler)\n\t}\n}\n\n/**\n * Layer for pointer (mouse/touch) and keyboard input.\n * See {@linkcode PointerControlLayer} and {@linkcode KeyboardControlLayer}.\n * @class\n * @param {Parameters<typeof PointerControlLayer>[0]} [mouseOpts]\n * @param {Parameters<typeof KeyboardControlLayer>[0]} [kbdOpts]\n */\nexport function ControlLayer(mouseOpts, kbdOpts) {\n\tconst items = [new PointerControlLayer(mouseOpts), new KeyboardControlLayer(kbdOpts)]\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.register = map => {\n\t\tfor (const item of items) item.register(map)\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.unregister = map => {\n\t\tfor (const item of items) item.unregister(map)\n\t}\n}\n\n/**\n * Should be used with `doNotInterfere:true` set on {@linkcode MouseControlLayer} or {@linkcode ControlLayer}.\n * Shows a text over the map when user input is ignored.\n * @class\n * @param {string} controlText text to be shown when `Ctrl`/`⌘` key is required to zoom.\n *   For example: `` `hold ${controlHintKeyName()} to zoom` ``.\n * @param {string} twoFingersText text to be shown when two fingers are required to drag.\n *   For example: `'use two fingers to drag'`.\n * @param {{styles:Record<string,string>}} [opts] text box style overrides\n */\nexport function ControlHintLayer(controlText, twoFingersText, opts) {\n\tconst elem = document.createElement('div')\n\telem.className = 'map-control-hint'\n\tapplyStyles(elem, {\n\t\tposition: 'absolute',\n\t\twidth: '100%',\n\t\theight: '100%',\n\t\tdisplay: 'flex',\n\t\talignItems: 'center',\n\t\tjustifyContent: 'center',\n\t\ttextAlign: 'center',\n\t\tcolor: 'rgba(0,0,0,0.7)',\n\t\tbackgroundColor: 'rgba(127,127,127,0.7)',\n\t\ttransition: 'opacity 0.25s ease',\n\t\topacity: '0',\n\t\tpointerEvents: 'none',\n\t\tfontSize: '42px',\n\t})\n\tif (opts?.styles) applyStyles(elem, opts?.styles)\n\n\tlet timeout = -1\n\tfunction showHint(text) {\n\t\tclearTimeout(timeout)\n\t\telem.textContent = text\n\t\telem.style.opacity = '1'\n\t\ttimeout = window.setTimeout(hideHint, 1000)\n\t}\n\tfunction hideHint() {\n\t\tclearTimeout(timeout)\n\t\telem.style.opacity = '0'\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.register = map => {\n\t\tmap.getWrap().appendChild(elem)\n\t}\n\t/** @param {import('./map').LocMap} map */\n\tthis.unregister = map => {\n\t\tmap.getWrap().removeChild(elem)\n\t}\n\n\t/** @type {import('./map').MapEventHandlers} */\n\tthis.onEvent = {\n\t\tmapMove: hideHint,\n\t\tmapZoom: hideHint,\n\t\tcontrolHint(map, e) {\n\t\t\tswitch (e.type) {\n\t\t\t\tcase 'use_control_to_zoom':\n\t\t\t\t\tshowHint(controlText)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'use_two_fingers':\n\t\t\t\t\tshowHint(twoFingersText)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t},\n\t}\n}\n\n/**\n * Returns `⌘` on MacOS/iOS and `Ctrl` on other platforms.\n * Useful for {@linkcode ControlHintLayer}.\n */\nexport function controlHintKeyName() {\n\treturn navigator.userAgent.includes('Macintosh') ? '⌘' : 'Ctrl'\n}\n","/**\n * Chooses and returns random argument.\n * @template T\n * @param  {...T} args\n * @returns {T}\n */\nexport function oneOf(...args) {\n\treturn args[(args.length * Math.random()) | 0]\n}\n\n/** @type {Partial<CSSStyleDeclaration>} */\nexport const CREDIT_BOTTOM_RIGHT = {\n\tposition: 'absolute',\n\tright: '0',\n\tbottom: '0',\n\tfont: '11px/1.5 sans-serif',\n\tbackground: 'white',\n\tpadding: '0 5px',\n\topacity: '0.75',\n}\n\n/**\n * Shortcut for appending some HTML at the right-bottom of another element.\n * @param {HTMLElement} wrap parent element, usually `map.getWrap()`\n * @param {string} html content as HTML (won't be escaped)\n * @param {Partial<CSSStyleDeclaration>} [style=CREDIT_BOTTOM_RIGHT] custom style object\n */\nexport function appendCredit(wrap, html, style = CREDIT_BOTTOM_RIGHT) {\n\tconst elem = document.createElement('div')\n\telem.className = 'map-credit'\n\telem.innerHTML = html\n\tapplyStyles(elem, style)\n\twrap.appendChild(elem)\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @param {number} x\n */\nexport function clamp(a, b, x) {\n\treturn Math.max(a, Math.min(b, x))\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {Partial<CSSStyleDeclaration>} style\n */\nexport function applyStyles(elem, style) {\n\tfor (const name in style) elem.style[name] = /**@type {string}*/ (style[name])\n}\n","/**\n * When `img` is `null`, the tile is considerend blank and not drawn (may be replaced by placeholder).\n *\n * When `img` is not `null`, the tile is considerend ready to be drawn.\n *\n * @template {HTMLImageElement|ImageBitmap|null} TImg\n * @typedef {{img:TImg, clear:(()=>unknown)|null, x:number, y:number, z:number, appearAt:number, lastDrawIter:number}} Tile\n */\n\n/** @typedef {Tile<null>} BlankTile */\n/** @typedef {Tile<HTMLImageElement>|Tile<ImageBitmap>} ImgTile */\n/** @typedef {BlankTile|ImgTile} AnyTile */\n\n/** @typedef {(img:HTMLImageElement|ImageBitmap|null, clear:()=>unknown) => unknown} TileUpdateFunc */\n/** @typedef {(x:number, y:number, z:number, onUpdate:TileUpdateFunc) => unknown} TileImgLoadFunc */\n/** @typedef {(x:number, y:number, z:number) => string} TilePathFunc */\n/** @typedef {(map:import('./map').LocMap, x:number, y:number, z:number, drawX:number, drawY:number, tileW:number, scale:number) => unknown} TilePlaceholderDrawFunc */\n\n/**\n * @param {HTMLImageElement|ImageBitmap} img\n * @returns {img is HTMLImageElement}\n */\nfunction isHtmlImg(img) {\n\treturn 'src' in img\n}\n\n/** @param {HTMLImageElement} img */\nfunction clearHtmlImg(img) {\n\timg.src = ''\n}\n/** @param {ImageBitmap} img */\nfunction clearBitmapImg(img) {\n\timg.close()\n}\n\n/**\n * @param {HTMLImageElement|ImageBitmap} img\n * @returns {number}\n */\nfunction getImgWidth(img) {\n\treturn isHtmlImg(img) ? img.naturalWidth : img.width\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} z\n * @returns {string}\n */\nfunction getTileKey(x, y, z) {\n\treturn `${x}|${y}|${z}`\n}\n\n/**\n * Loads, caches and draws tiles with transitions. To be used with {@linkcode TileLayer}.\n * @class\n * @param {number} tileW tile display size\n * @param {TileImgLoadFunc} tileLoadFunc loads tile image,\n *   see {@linkcode loadTileImage} and maybe {@linkcode clampEarthTiles}\n * @param {TilePlaceholderDrawFunc} [tilePlaceholderDrawFunc]\n *   draws placeholder when tile is not ready or has failed to load\n *   (for example, {@linkcode drawRectTilePlaceholder})\n */\nexport function SmoothTileContainer(tileW, tileLoadFunc, tilePlaceholderDrawFunc) {\n\tconst cache = /** @type {Map<string,AnyTile>} */ (new Map())\n\n\tlet lastDrawnTiles = /**@type {Set<ImgTile>}*/ (new Set())\n\tconst lastDrawnUnderLevelTilesArr = /**@type {ImgTile[]}*/ ([])\n\n\t/** @type {[iFrom:number, jFrom:number, iCount:number, jCount:number, level:number]} */\n\tlet prevTileRegion = [0, 0, 0, 0, 0]\n\n\tlet drawIter = 0\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} z\n\t * @returns {AnyTile}\n\t */\n\tfunction makeTile(map, x, y, z) {\n\t\tconst tile = /** @type {AnyTile} */ ({\n\t\t\timg: null,\n\t\t\tclear: null,\n\t\t\tx,\n\t\t\ty,\n\t\t\tz,\n\t\t\tappearAt: 0,\n\t\t\t// writing here last iter (instead of 0), so if tile load will abort/fail,\n\t\t\t// this tile won't be the \"oldest\" one in the cache and won't be quickly removed\n\t\t\tlastDrawIter: drawIter,\n\t\t})\n\t\ttileLoadFunc(x, y, z, (img, clear) => {\n\t\t\ttile.img = img\n\t\t\ttile.clear = clear\n\t\t\tmap.requestRedraw()\n\t\t})\n\t\treturn tile\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} i\n\t * @param {number} j\n\t * @param {number} level\n\t * @param {boolean} loadIfMissing\n\t */\n\tfunction findTile(map, i, j, level, loadIfMissing) {\n\t\tconst key = getTileKey(i, j, level)\n\t\tlet tile = cache.get(key)\n\t\tif (!tile && loadIfMissing) {\n\t\t\ttile = makeTile(map, i, j, level)\n\t\t\tcache.set(key, tile)\n\t\t}\n\t\treturn tile\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} i\n\t * @param {number} j\n\t * @param {number} level\n\t * @param {boolean} useOpacity\n\t */\n\tfunction canFullyDrawRecentTile(map, i, j, level, useOpacity) {\n\t\tconst tile = findTile(map, i, j, level, false)\n\t\treturn (\n\t\t\t!!tile &&\n\t\t\t!!tile.img &&\n\t\t\t// if tile not drawn recently, it will became transparent on next draw\n\t\t\ttileDrawnRecently(tile) &&\n\t\t\t(!useOpacity || getTileOpacity(tile) >= 1)\n\t\t)\n\t}\n\n\t/** @param {AnyTile} tile */\n\tfunction getTileOpacity(tile) {\n\t\treturn (performance.now() - tile.appearAt) / 150\n\t}\n\n\t/** @param {AnyTile} tile */\n\tfunction tileDrawnRecently(tile) {\n\t\treturn tile.lastDrawIter >= drawIter - 1\n\t}\n\n\t/** @param {AnyTile} tile */\n\tfunction tileWasOutsideOnCurLevel(tile) {\n\t\tconst [iFrom, jFrom, iCount, jCount, level] = prevTileRegion\n\t\tconst { x, y, z } = tile\n\t\treturn z === level && (x < iFrom || x >= iFrom + iCount || y < jFrom || y >= jFrom + jCount)\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {ImgTile} tile\n\t * @param {boolean} withOpacity\n\t * @param {number} sx\n\t * @param {number} sy\n\t * @param {number} sw\n\t * @param {number} sh\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} w\n\t * @param {number} h\n\t */\n\tfunction drawTile(map, tile, withOpacity, sx, sy, sw, sh, x, y, w, h) {\n\t\tconst rc = map.get2dContext()\n\t\tif (!rc) return\n\n\t\tif (!tileDrawnRecently(tile)) {\n\t\t\t// Preventing fade-in animation for loaded tiles which appeared on sides while moving the map.\n\t\t\t// This works only for tiles on current level but is simplier and is enough for most cases.\n\t\t\tif (tileWasOutsideOnCurLevel(tile)) tile.appearAt = 0\n\t\t\t// making it \"appear\" a bit earlier, so now tile won't be fully transparent\n\t\t\telse tile.appearAt = performance.now() - 16\n\t\t}\n\t\ttile.lastDrawIter = drawIter\n\t\tlastDrawnTiles.add(tile)\n\n\t\tconst s = devicePixelRatio\n\t\t// rounding to real canvas pixels\n\t\tconst rx = Math.round(x * s) / s\n\t\tconst ry = Math.round(y * s) / s\n\t\tw = Math.round((x + w) * s) / s - rx\n\t\th = Math.round((y + h) * s) / s - ry\n\t\tconst alpha = withOpacity ? getTileOpacity(tile) : 1\n\n\t\tif (alpha < 1) rc.globalAlpha = alpha\n\t\trc.drawImage(tile.img, sx, sy, sw, sh, rx, ry, w, h)\n\t\t// rc.fillText(tile.x + '/' + tile.y, rx, ry + 12)\n\t\tif (alpha < 1) {\n\t\t\trc.globalAlpha = 1\n\t\t\tmap.requestRedraw()\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} scale\n\t * @param {number} i\n\t * @param {number} j\n\t * @param {number} level\n\t * @param {number} tileX\n\t * @param {number} tileY\n\t * @param {number} tileZ\n\t * @param {boolean} loadIfMissing\n\t * @param {boolean} useOpacity\n\t * @returns {boolean}\n\t */\n\tfunction tryDrawTile(map, x, y, scale, i, j, level, tileX, tileY, tileZ, loadIfMissing, useOpacity) {\n\t\tconst tile = findTile(map, tileX, tileY, tileZ, loadIfMissing)\n\t\treturn !!tile && tryDrawTileObj(map, tile, x, y, scale, i, j, level, useOpacity)\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {AnyTile} tile\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} scale\n\t * @param {number} i\n\t * @param {number} j\n\t * @param {number} level\n\t * @param {boolean} useOpacity\n\t * @returns {boolean}\n\t */\n\tfunction tryDrawTileObj(map, tile, x, y, scale, i, j, level, useOpacity) {\n\t\tif (!tile.img) return false\n\t\tconst dlevel = tile.z - level\n\t\tconst dzoom = 2 ** dlevel\n\t\tconst di = tile.x - i * dzoom\n\t\tconst dj = tile.y - j * dzoom\n\t\tconst imgW = getImgWidth(tile.img)\n\n\t\tlet sx, sy, sw, dw\n\t\tif (dlevel >= 0) {\n\t\t\tif (di < 0 || dj < 0 || di >= dzoom || dj >= dzoom) return false\n\t\t\tdw = (tileW * scale) / dzoom\n\t\t\tx += di * dw\n\t\t\ty += dj * dw\n\t\t\tsx = 0\n\t\t\tsy = 0\n\t\t\tsw = imgW\n\t\t} else {\n\t\t\tsw = imgW * dzoom\n\t\t\tsx = -di * imgW\n\t\t\tsy = -dj * imgW\n\t\t\tif (sx < 0 || sy < 0 || sx >= imgW || sy >= imgW) return false\n\t\t\tdw = tileW * scale\n\t\t}\n\n\t\tdrawTile(map, tile, useOpacity,\n\t\t         sx,sy, sw,sw,\n\t\t         x,y, dw,dw) //prettier-ignore\n\t\treturn true\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} scale\n\t * @param {number} i\n\t * @param {number} j\n\t * @param {number} level\n\t * @param {boolean} shouldLoad\n\t */\n\tfunction drawOneTile(map, x, y, scale, i, j, level, shouldLoad) {\n\t\tif (!canFullyDrawRecentTile(map, i, j, level, true)) {\n\t\t\t//prettier-ignore\n\t\t\tconst canFillByQuaters =\n\t\t\t\tcanFullyDrawRecentTile(map, i*2,   j*2,   level+1, false) &&\n\t\t\t\tcanFullyDrawRecentTile(map, i*2,   j*2+1, level+1, false) &&\n\t\t\t\tcanFullyDrawRecentTile(map, i*2+1, j*2,   level+1, false) &&\n\t\t\t\tcanFullyDrawRecentTile(map, i*2+1, j*2+1, level+1, false)\n\n\t\t\tlet upperTileDrawn = false\n\t\t\tif (!canFillByQuaters) {\n\t\t\t\t// drawing upper tiles parts\n\t\t\t\tconst topLevel = Math.max(level - 5, Math.log2(map.getZoomRange()[0] / tileW) - 1)\n\t\t\t\tfor (let l = level - 1; l >= topLevel; l--) {\n\t\t\t\t\tconst sub = level - l\n\t\t\t\t\tupperTileDrawn = tryDrawTile(map, x,y,scale, i,j,level, i>>sub,j>>sub,level-sub, false, false) //prettier-ignore\n\t\t\t\t\tif (upperTileDrawn) break\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet lowerTilesDrawn = false\n\t\t\tif (!upperTileDrawn) {\n\t\t\t\ttilePlaceholderDrawFunc?.(map, i, j, level, x, y, tileW, scale)\n\t\t\t\tif (canFillByQuaters) {\n\t\t\t\t\t// drawing lower tiles as 2x2\n\t\t\t\t\tfor (let di = 0; di <= 1; di++)\n\t\t\t\t\t\tfor (let dj = 0; dj <= 1; dj++)\n\t\t\t\t\t\t\ttryDrawTile(map, x, y, scale, i, j, level, i*2+di, j*2+dj, level+1, false, false) //prettier-ignore\n\t\t\t\t\tlowerTilesDrawn = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// drawing additional (to 2x2) lower tiles from previous frames, useful for fast zoom-out animation.\n\t\t\tfor (let k = 0; k < lastDrawnUnderLevelTilesArr.length; k++) {\n\t\t\t\tconst tile = lastDrawnUnderLevelTilesArr[k]\n\t\t\t\t// skipping layer+1 if it was handled by upper 2x2\n\t\t\t\tif (!lowerTilesDrawn || tile.z >= level + 2)\n\t\t\t\t\ttryDrawTileObj(map, tile, x, y, scale, i, j, level, true)\n\t\t\t}\n\t\t}\n\n\t\ttryDrawTile(map, x, y, scale, i, j, level, i, j, level, shouldLoad, true)\n\t}\n\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} xShift\n\t * @param {number} yShift\n\t * @param {number} scale\n\t * @param {number} iFrom\n\t * @param {number} jFrom\n\t * @param {number} iCount\n\t * @param {number} jCount\n\t * @param {number} level\n\t * @param {boolean} shouldLoad\n\t */\n\tthis.draw = (map, xShift, yShift, scale, iFrom, jFrom, iCount, jCount, level, shouldLoad) => {\n\t\tconst [mapViewWidth, mapViewheight] = map.getViewBoxSize()\n\t\t// view size in tiles (extended a bit: it's needed for larger lastDrawnUnderLevelTilesArr and drawOneTile())\n\t\tconst tileViewSizeExt = Math.ceil(mapViewWidth / tileW + 1) * Math.ceil(mapViewheight / tileW + 1)\n\n\t\t// refilling recent tiles array\n\t\tlastDrawnUnderLevelTilesArr.length = 0\n\t\tlastDrawnTiles.forEach(\n\t\t\tx =>\n\t\t\t\tx.z >= level + 1 &&\n\t\t\t\tlastDrawnUnderLevelTilesArr.length < tileViewSizeExt * 2 && //limiting max lower tile count, just in case\n\t\t\t\tlastDrawnUnderLevelTilesArr.push(x),\n\t\t)\n\t\tlastDrawnTiles.clear()\n\t\tdrawIter++\n\n\t\t// start loading some center tiles first, sometimes useful on slow connections\n\t\tif (shouldLoad)\n\t\t\tfor (let i = (iCount / 3) | 0; i < (iCount * 2) / 3; i++)\n\t\t\t\tfor (let j = (jCount / 3) | 0; j < (jCount * 2) / 3; j++) {\n\t\t\t\t\tfindTile(map, iFrom + i, jFrom + j, level, true)\n\t\t\t\t}\n\n\t\t// drawing tiles\n\t\tfor (let i = 0; i < iCount; i++)\n\t\t\tfor (let j = 0; j < jCount; j++) {\n\t\t\t\tconst x = xShift + i * tileW * scale\n\t\t\t\tconst y = yShift + j * tileW * scale\n\t\t\t\tdrawOneTile(map, x, y, scale, iFrom + i, jFrom + j, level, shouldLoad)\n\t\t\t}\n\n\t\t// limiting cache size\n\t\tconst cacheMaxSize = (8 * tileViewSizeExt) | 0\n\t\tfor (let attempt = 0; attempt < 4 && cache.size > cacheMaxSize; attempt++) {\n\t\t\tlet oldestIter = drawIter - 1 //must not affect recently drawn tiles\n\t\t\tcache.forEach(tile => (oldestIter = Math.min(oldestIter, tile.lastDrawIter)))\n\t\t\tcache.forEach((tile, key) => {\n\t\t\t\tif (tile.lastDrawIter === oldestIter) {\n\t\t\t\t\tcache.delete(key)\n\t\t\t\t\tlastDrawnTiles.delete(/**@type {ImgTile}*/ (tile))\n\t\t\t\t\ttile.clear?.()\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tprevTileRegion = [iFrom, jFrom, iCount, jCount, level]\n\t}\n\n\tthis.getTileWidth = () => tileW\n\n\tthis.clearCache = () => {\n\t\tcache.forEach(x => x.clear?.())\n\t\tcache.clear()\n\t\tlastDrawnTiles.clear()\n\t\tlastDrawnUnderLevelTilesArr.length = 0\n\t}\n}\n\n/**\n * Loads image for {@linkcode TileContainer}s ({@linkcode SmoothTileContainer} for example).\n * @param {TilePathFunc} pathFunc tile path func, for example:\n *   ``(x, y, z) => `http://${oneOf('a', 'b', 'c')}.tile.openstreetmap.org/${z}/${x}/${y}.png` ``\n * @returns {TileImgLoadFunc}\n */\nexport function loadTileImage(pathFunc) {\n\treturn (x, y, z, onUpdate) => {\n\t\tconst img = new Image()\n\t\timg.src = pathFunc(x, y, z)\n\t\tconst clearHtmlImg_ = () => clearHtmlImg(img)\n\t\timg.onload = () => {\n\t\t\tconst createImageBitmap = window.createImageBitmap\n\t\t\tif (createImageBitmap) {\n\t\t\t\t// trying no decode image in parallel thread,\n\t\t\t\t// if failed (beacuse of CORS for example) tryimg to show image anyway\n\t\t\t\tcreateImageBitmap(img).then(\n\t\t\t\t\tx => onUpdate(x, () => clearBitmapImg(x)),\n\t\t\t\t\t() => onUpdate(img, clearHtmlImg_),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tonUpdate(img, clearHtmlImg_)\n\t\t\t}\n\t\t}\n\t\tonUpdate(null, clearHtmlImg_)\n\t}\n}\n\n/**\n * Wrapper for {@linkcode TilePathFunc} (like {@linkcode loadTileImage}).\n * Skips loading tiles outside of the map square (1x1 on level 0, 2x2 on level 1, etc.).\n *\n * @param {TileImgLoadFunc} tileFunc\n * @returns {TileImgLoadFunc}\n */\nexport function clampEarthTiles(tileFunc) {\n\treturn (x, y, z, onUpdate) => {\n\t\tconst w = 2 ** z\n\t\tif (z < 0 || x < 0 || x >= w || y < 0 || y >= w) return\n\t\ttileFunc(x, y, z, onUpdate)\n\t}\n}\n\n/**\n * Draws simple tile placeholder (semi-transparent square).\n *\n * @param {import('./map').LocMap} map\n * @param {number} x tile column index\n * @param {number} y tile row index\n * @param {number} z tile level\n * @param {number} drawX location on canvas\n * @param {number} drawY location on canvas\n * @param {number} tileW current tile size\n * @param {number} scale tile scale relative to it's regular size (displaying size is `tileW*scale`)\n */\nexport function drawRectTilePlaceholder(map, x, y, z, drawX, drawY, tileW, scale) {\n\tconst rc = map.get2dContext()\n\tif (rc === null) return\n\tconst w = tileW * scale\n\tconst margin = 1.5\n\trc.strokeStyle = '#8883'\n\trc.strokeRect(drawX + margin, drawY + margin, w - margin * 2, w - margin * 2)\n}\n","/**\n * @typedef {object} TileContainer\n * @prop {() => unknown} clearCache\n * @prop {() => number} getTileWidth\n * @prop {(map:import('./map').LocMap,\n *   xShift:number, yShift:number, scale:number,\n *   iFrom:number, jFrom:number, iCount:number, jCount:number, level:number,\n *   shouldLoad: boolean) => unknown} draw\n */\n\n/**\n * Loads and draw tiles using {@linkcode TileContainer}.\n * Disables tile load while zooming.\n * @class\n * @param {TileContainer} tileContainer tile cache/drawer, for example {@linkcode SmoothTileContainer}\n */\nexport function TileLayer(tileContainer) {\n\tlet shouldLoadTiles = true\n\tlet lastZoomAt = 0\n\tlet curZoomTotalDelta = 1\n\tlet tileLoadOffTimeout = -1\n\tlet tileLoadPausedAt = 0\n\t/**\n\t * @param {import('./map').LocMap} map\n\t * @param {number} durationMS\n\t */\n\tfunction pauseTileLoad(map, durationMS) {\n\t\tif (shouldLoadTiles) {\n\t\t\ttileLoadPausedAt = performance.now()\n\t\t\tshouldLoadTiles = false\n\t\t}\n\t\tclearTimeout(tileLoadOffTimeout)\n\t\ttileLoadOffTimeout = window.setTimeout(() => {\n\t\t\tshouldLoadTiles = true\n\t\t\tmap.requestRedraw()\n\t\t}, durationMS)\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.unregister = map => {\n\t\ttileContainer.clearCache()\n\t}\n\n\t/** @param {import('./map').LocMap} map */\n\tthis.redraw = map => {\n\t\tconst tileW = tileContainer.getTileWidth()\n\t\t//extra level shift (not 0.5), or on half-level zoom text on tiles may be too small\n\t\tconst level = Math.floor(Math.log2(map.getZoom() / tileW) + 0.4)\n\t\tconst tileGridSize = 2 ** level\n\t\tconst scale = map.getZoom() / tileW / tileGridSize\n\t\tconst blockSize = tileW * scale\n\t\tconst [mapXShift, mapYShift] = map.getViewBoxShift()\n\t\tconst [mapViewWidth, mapViewHeight] = map.getViewBoxSize()\n\n\t\tconst iFrom = Math.floor(mapXShift / blockSize)\n\t\tconst xShift = -mapXShift + iFrom * blockSize\n\n\t\tconst jFrom = Math.floor(mapYShift / blockSize)\n\t\tconst yShift = -mapYShift + jFrom * blockSize\n\n\t\tconst iCount = (((mapViewWidth - xShift) / blockSize) | 0) + 1\n\t\tconst jCount = (((mapViewHeight - yShift) / blockSize) | 0) + 1\n\n\t\ttileContainer.draw(map, xShift, yShift, scale, iFrom, jFrom, iCount, jCount, level, shouldLoadTiles)\n\t}\n\n\t/** @type {import('./map').MapEventHandlers} */\n\tthis.onEvent = {\n\t\tmapZoom(map, { delta }) {\n\t\t\tconst now = performance.now()\n\t\t\tconst timeDelta = now - lastZoomAt\n\t\t\tif (timeDelta > 250) curZoomTotalDelta = 1 //new zoom action started\n\t\t\tlastZoomAt = now\n\t\t\tcurZoomTotalDelta *= delta\n\n\t\t\t// if zoomed enough\n\t\t\tif (curZoomTotalDelta < 1 / 1.2 || curZoomTotalDelta > 1.2) {\n\t\t\t\t// if fast enough\n\t\t\t\tconst isFast = timeDelta === 0 || Math.abs(delta ** (1 / timeDelta) - 1) > 0.0005\n\t\t\t\tif (isFast) {\n\t\t\t\t\t// unpausing periodically in case of long slow zooming\n\t\t\t\t\tif (shouldLoadTiles || now - tileLoadPausedAt > 1000) pauseTileLoad(map, 80)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n}\n","/**\n * @typedef {[\n *   level: number,\n *   rect: [left:number, top:number, right:number, bottom:number],\n *   maskStr: string\n * ]} TileLayerSummary\n */\n\nconst COUNT_CHAR_FIRST = 35\nconst COUNT_CHAR_LAST = 125\nconst EXTRA_CHAR = 126\n\n/** @param {Uint8Array} mask */\nexport function encodeLayerMask(mask) {\n\tlet maskStr = ''\n\tlet prevVal = 0\n\tlet rangeStartI = 0\n\tfor (let i = 0; i < mask.length; i++) {\n\t\tconst delta = i - rangeStartI\n\t\tconst isMaxLen = delta === COUNT_CHAR_LAST - COUNT_CHAR_FIRST\n\t\tconst hasChanged = mask[i] !== prevVal\n\t\tif (hasChanged || isMaxLen) {\n\t\t\tmaskStr += String.fromCharCode(hasChanged ? COUNT_CHAR_FIRST + delta : EXTRA_CHAR)\n\t\t\tprevVal = mask[i]\n\t\t\trangeStartI = i\n\t\t}\n\t}\n\tconst delta = mask.length - rangeStartI\n\tif (delta > 0) maskStr += String.fromCharCode(COUNT_CHAR_FIRST + delta)\n\treturn maskStr\n}\n\n/**\n * @param {string} maskStr\n * @param {number} size\n */\nexport function decodeLayerMask(maskStr, size) {\n\tlet mask = new Uint8Array(size)\n\tlet val = 0\n\tlet rangeStartI = 0\n\tlet i, code, isExtra, rangeEndI\n\tfor (i = 0; i < maskStr.length; i++) {\n\t\tcode = maskStr.charCodeAt(i)\n\t\tisExtra = code === EXTRA_CHAR\n\t\trangeEndI = rangeStartI + ((isExtra ? COUNT_CHAR_LAST : code) - COUNT_CHAR_FIRST)\n\t\tmask.fill(val, rangeStartI, rangeEndI)\n\t\trangeStartI = rangeEndI\n\t\tval ^= /**@type {*}*/ (!isExtra)\n\t}\n\treturn mask\n}\n\n/**\n * @param {TileLayerSummary[]} layersInfo\n * @returns {(x:number, y:number, z:number) => boolean}\n */\nexport function makeTileMaskChecker(layersInfo) {\n\tconst level2func = /**@type {Map<number,(i:number, j:number) => boolean>}*/ (new Map())\n\tfor (const item of layersInfo) {\n\t\tconst [level, [left, top, right, bottom], maskStr] = item\n\t\tconst width = right - left + 1\n\t\tconst height = bottom - top + 1\n\t\tconst mask = decodeLayerMask(maskStr, width * height)\n\t\tlevel2func.set(\n\t\t\tlevel,\n\t\t\t(i, j) =>\n\t\t\t\ti >= left && //\n\t\t\t\ti <= right &&\n\t\t\t\tj >= top &&\n\t\t\t\tj <= bottom &&\n\t\t\t\t!!mask[i - left + (j - top) * width],\n\t\t)\n\t}\n\treturn (i, j, level) => !!level2func.get(level)?.(i, j)\n}\n","import {\n\tControlLayer,\n\tdrawRectTilePlaceholder,\n\tloadTileImage,\n\tLocMap,\n\tMapEventHandlers,\n\tProjectionConverter,\n\tSmoothTileContainer,\n\tTileContainer,\n\tTileImgLoadFunc,\n\tTileLayer,\n\tTilePlaceholderDrawFunc,\n} from 'locmap'\nimport { useEffect, useRef } from 'preact/hooks'\nimport { makeTileMaskChecker, TileLayerSummary } from 'teyvat-map/tiles/summary'\n\nimport { MapCode } from '#lib/genshin'\nimport { clamp } from '#lib/utils/values'\nimport { checkAvifSupport } from '#lib/utils/web_media'\nimport { memo } from '#src/utils/preact-compat'\n\nconst TILE_DRAW_WIDTH = 192\nconst TILE_CONTENT_WIDTH = 256 //tile width in game pixels on layer 0\nconst MIN_LEVEL = -5.5\nconst MAX_LEVEL = 1\nconst DEFAULT_LEVEL = -1.2\nconst MARKERS_AUTO_REGION_DOWNSCALE = 1.25\nconst MARKER_ICON_SIZE_PX = 40\n\ntype TileExt = 'jpg' | 'avif'\n\nlet tileExt: TileExt = 'jpg'\nif (!BUNDLE_ENV.IS_SSR) checkAvifSupport().then(ok => ok && (tileExt = 'avif'))\n\nconst TILES_ROOT = `https://genshin-base.github.io/teyvat-map/v3.1/tiles`\n\nfunction tilePathFinc(x: number, y: number, z: number, mapCode: MapCode) {\n\treturn `${TILES_ROOT}/${mapCode}/${tileExt}/${z}/${x}/${y}.${tileExt}`\n}\n\nconst lowestLayerSummaries: Record<string, TileLayerSummary | undefined> = {}\nconst tilesMask: Record<string, ReturnType<typeof makeTileMaskChecker> | undefined> = {}\nif (!BUNDLE_ENV.IS_SSR)\n\tfetch(`${TILES_ROOT}/summary.json`)\n\t\t.then(r => r.json())\n\t\t.then((summaries: Record<string, TileLayerSummary[]>) => {\n\t\t\tfor (const code in summaries) {\n\t\t\t\tlowestLayerSummaries[code] = summaries[code][0]\n\t\t\t\ttilesMask[code] = makeTileMaskChecker(summaries[code])\n\t\t\t}\n\t\t})\n\nconst MapProjection: ProjectionConverter = {\n\tx2lon(x, zoom) {\n\t\treturn (x / zoom) * TILE_CONTENT_WIDTH\n\t},\n\ty2lat(y, zoom) {\n\t\treturn (y / zoom) * TILE_CONTENT_WIDTH\n\t},\n\n\tlon2x(lon, zoom) {\n\t\treturn (lon * zoom) / TILE_CONTENT_WIDTH\n\t},\n\tlat2y(lat, zoom) {\n\t\treturn (lat * zoom) / TILE_CONTENT_WIDTH\n\t},\n\n\tmeters2pixCoef(lat, zoom) {\n\t\treturn zoom / TILE_CONTENT_WIDTH\n\t},\n}\n\nexport type MapMarkerStyle = null | undefined | 'circle' | 'outline'\nexport type MapMarkerRaw = { mapCode: MapCode; x: number; y: number; icon: string; style?: MapMarkerStyle }\ntype MapMarkerIcon = { img: null | HTMLImageElement | HTMLCanvasElement }\ntype MapMarker = {\n\tmapCode: MapCode\n\tx: number\n\ty: number\n\ticon: MapMarkerIcon\n\tstyle: MapMarkerStyle\n}\n\nexport const TeyvatMap = memo(function TeyvatMap({\n\tclasses = '',\n\tmapCode,\n\tpos,\n\tmarkers,\n}: {\n\tclasses?: string\n\tmapCode: MapCode\n\tpos: { x: number; y: number; level: number } | 'auto'\n\tmarkers?: MapMarkerRaw[]\n}) {\n\tconst wrapRef = useRef<HTMLDivElement>(null)\n\tconst mapRef = useRef<{\n\t\tmap: LocMap\n\t\tmarkersLayer: MarkersLayer\n\t\tmovementClampLayer: MovementClampLayer\n\t\ttileContainer: TileContainer\n\t} | null>(null)\n\tconst mapCodeRef = useRef<MapCode>('teyvat')\n\n\tuseEffect(() => {\n\t\tif (!wrapRef.current) return\n\n\t\tfunction shouldDrawTile(x: number, y: number, z: number) {\n\t\t\tconst mask = tilesMask[mapCodeRef.current]\n\t\t\treturn !mask || mask(x, y, z)\n\t\t}\n\n\t\tconst drawTilePlaceholder: TilePlaceholderDrawFunc = (map, x, y, z, drawX, drawY, tileW, scale) => {\n\t\t\tif (shouldDrawTile(x, y, z)) drawRectTilePlaceholder(map, x, y, z, drawX, drawY, tileW, scale)\n\t\t}\n\n\t\tconst loadTileInner = loadTileImage((x, y, z) => tilePathFinc(x, y, z, mapCodeRef.current))\n\t\tconst loadTile: TileImgLoadFunc = (x, y, z, onUpdate) => {\n\t\t\tif (shouldDrawTile(x, y, z)) loadTileInner(x, y, z, onUpdate)\n\t\t}\n\t\tconst tileContainer = new SmoothTileContainer(TILE_DRAW_WIDTH, loadTile, drawTilePlaceholder)\n\n\t\tconst map = new LocMap(wrapRef.current, MapProjection)\n\t\tconst markersLayer = new MarkersLayer()\n\t\tconst movementClampLayer = new MovementClampLayer()\n\t\tmap.setZoomRange(2 ** MIN_LEVEL * TILE_CONTENT_WIDTH, 2 ** MAX_LEVEL * TILE_CONTENT_WIDTH)\n\t\tmap.register(movementClampLayer)\n\t\tmap.register(new TileLayer(tileContainer))\n\t\tmap.register(markersLayer)\n\t\tmap.register(new ControlLayer())\n\t\tmap.requestRedraw()\n\t\tmap.resize()\n\n\t\taddEventListener('resize', map.resize)\n\t\tmapRef.current = { map, markersLayer, movementClampLayer, tileContainer }\n\n\t\treturn () => {\n\t\t\tmap.getLayers().forEach(map.unregister)\n\t\t\tremoveEventListener('resize', map.resize)\n\t\t\tmapRef.current = null\n\t\t}\n\t}, [])\n\n\tuseEffect(() => {\n\t\tconst m = mapRef.current\n\t\tmapCodeRef.current = mapCode\n\t\tm?.markersLayer.setMapCode(mapCode)\n\t\tm?.movementClampLayer.setMapCode(mapCode)\n\t\tm?.tileContainer.clearCache()\n\t\tm?.map.requestRedraw()\n\t}, [mapCode])\n\n\tuseEffect(() => {\n\t\tmapRef.current?.markersLayer.setMarkers(markers ?? [])\n\t}, [markers])\n\n\tuseEffect(() => {\n\t\tconst map = mapRef.current?.map\n\t\tif (!map) return\n\t\tconst { x, y, level } = pos === 'auto' ? calcAutoPosition(map, markers ?? [], mapCode) : pos\n\t\tmap.updateLocation(x, y, TILE_CONTENT_WIDTH * 2 ** level)\n\t}, [pos, markers, mapCode])\n\n\treturn (\n\t\t<div\n\t\t\tref={wrapRef}\n\t\t\tclass={'teyvat-map position-relative ' + classes}\n\t\t\tstyle={{ backgroundColor: 'black' }}\n\t\t></div>\n\t)\n})\n\nfunction calcAutoPosition(map: LocMap, markers: MapMarkerRaw[], mapCode: MapCode) {\n\tlet xMin = 1e10\n\tlet xMax = -1e10\n\tlet yMin = 1e10\n\tlet yMax = -1e10\n\tfor (const marker of markers) {\n\t\tif (marker.mapCode !== mapCode) continue\n\t\tif (xMin > marker.x) xMin = marker.x\n\t\tif (xMax < marker.x) xMax = marker.x\n\t\tif (yMin > marker.y) yMin = marker.y\n\t\tif (yMax < marker.y) yMax = marker.y\n\t}\n\n\tconst [w, h] = map.getViewBoxSize()\n\tconst zoom = Math.min(w / (xMax - xMin), h / (yMax - yMin)) / MARKERS_AUTO_REGION_DOWNSCALE\n\t// zoom==inf -> one marker, zoom<0 -> no markers\n\tlet level = zoom === Infinity || zoom < 0 ? DEFAULT_LEVEL : Math.log2(zoom)\n\tlevel = clamp(MIN_LEVEL, level, MAX_LEVEL)\n\n\treturn { x: (xMin + xMax) / 2, y: (yMin + yMax) / 2, level }\n}\n\nclass MarkersLayer {\n\tprivate map: LocMap | null = null\n\tprivate markers: MapMarker[] = []\n\tprivate iconCache: Map<string, MapMarkerIcon> = new Map()\n\tprivate mapCode: MapCode = 'teyvat'\n\n\tprivate loadMarkerImg(src: string, style: MapMarkerStyle) {\n\t\tconst key = src + '|' + style\n\t\tconst cachedIcon = this.iconCache.get(key)\n\t\tif (cachedIcon) {\n\t\t\tif (cachedIcon.img) this.map?.requestRedraw()\n\t\t\treturn cachedIcon\n\t\t} else {\n\t\t\tconst img = new Image()\n\t\t\tconst icon: MapMarkerIcon = { img: null }\n\t\t\timg.src = src\n\t\t\timg.onload = () => {\n\t\t\t\ticon.img =\n\t\t\t\t\tstyle === 'outline'\n\t\t\t\t\t\t? makeCanvasWithShadow(img, 1, 'black') //\n\t\t\t\t\t\t: img\n\t\t\t\tthis.map?.requestRedraw()\n\t\t\t}\n\t\t\tthis.iconCache.set(key, icon)\n\t\t\treturn icon\n\t\t}\n\t}\n\n\tsetMapCode(mapCode: MapCode) {\n\t\tthis.mapCode = mapCode\n\t}\n\n\tsetMarkers(rawMarkers: MapMarkerRaw[]) {\n\t\tthis.markers.length = 0\n\t\t{\n\t\t\tconst cache = this.iconCache\n\t\t\tfor (const key of cache.keys()) {\n\t\t\t\tif (cache.size < 30) break\n\t\t\t\tcache.delete(key)\n\t\t\t}\n\t\t}\n\t\tfor (const raw of rawMarkers) {\n\t\t\tconst marker = { ...raw, icon: this.loadMarkerImg(raw.icon, raw.style), style: raw.style }\n\t\t\tthis.markers.push(marker)\n\t\t}\n\t}\n\n\tredraw(map: LocMap) {\n\t\tconst rc = map.get2dContext()\n\t\tif (!rc) return\n\n\t\tconst [viewX, viewY] = map.getViewBoxShift()\n\t\tconst zoomDownscale = Math.min(1, (map.getZoom() / TILE_DRAW_WIDTH - 1) / 2 + 1)\n\n\t\tfor (let i = 0, markers = this.markers; i < markers.length; i++) {\n\t\t\tconst marker = markers[i]\n\t\t\tif (marker.mapCode !== this.mapCode) continue\n\n\t\t\tconst x = map.lon2x(marker.x) - viewX\n\t\t\tconst y = map.lat2y(marker.y) - viewY\n\t\t\tconst size = MARKER_ICON_SIZE_PX * zoomDownscale\n\t\t\tconst lineW = 1.5 * zoomDownscale\n\t\t\tconst isCircled = marker.style === 'circle'\n\n\t\t\tif (isCircled) {\n\t\t\t\trc.beginPath()\n\t\t\t\trc.arc(x, y, size / 2 + lineW / 2 + 0.75, 0, Math.PI * 2, false)\n\t\t\t\trc.fillStyle = '#333'\n\t\t\t\trc.fill()\n\t\t\t}\n\n\t\t\tconst img = marker.icon.img\n\t\t\tif (img !== null) {\n\t\t\t\tconst isImg = 'naturalWidth' in img\n\t\t\t\tconst nw = isImg ? img.naturalWidth : img.width\n\t\t\t\tconst nh = isImg ? img.naturalHeight : img.height\n\t\t\t\tconst scale = Math.min(size / nw, size / nh)\n\t\t\t\tconst w = nw * scale\n\t\t\t\tconst h = nh * scale\n\t\t\t\tif (isCircled) {\n\t\t\t\t\trc.save()\n\t\t\t\t\trc.beginPath()\n\t\t\t\t\trc.arc(x, y, size / 2 - lineW / 2 - 0.75, 0, Math.PI * 2, false)\n\t\t\t\t\trc.clip()\n\t\t\t\t}\n\t\t\t\trc.drawImage(img, x - w / 2, y - h / 2, w, h)\n\t\t\t\tif (isCircled) {\n\t\t\t\t\trc.restore()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCircled) {\n\t\t\t\trc.beginPath()\n\t\t\t\trc.arc(x, y, size / 2, 0, Math.PI * 2, false)\n\t\t\t\trc.strokeStyle = 'white'\n\t\t\t\trc.lineWidth = lineW\n\t\t\t\trc.stroke()\n\t\t\t}\n\t\t}\n\t}\n\n\tregister(map: LocMap) {\n\t\tthis.map = map\n\t}\n\n\tunregister(map: LocMap) {\n\t\tthis.map = null\n\t\tthis.markers.length = 0\n\t}\n}\n\nfunction makeCanvasWithShadow(img: HTMLImageElement, blur: number, color: string) {\n\tconst canvas = document.createElement('canvas')\n\tcanvas.width = img.naturalWidth\n\tcanvas.height = img.naturalHeight\n\tconst rc = canvas.getContext('2d')\n\tif (rc) {\n\t\trc.shadowBlur = blur\n\t\trc.shadowColor = color\n\t\tfor (let i = 0; i < 3; i++) rc.drawImage(img, 0, 0)\n\t}\n\treturn canvas\n}\n\nclass MovementClampLayer {\n\tprivate mapCode: MapCode = 'teyvat'\n\tprivate isGrabbing = false\n\tprivate isZoomIn = false\n\t// расширение границ таскаяни, в координатах карты\n\tprivate xOffset = 0\n\tprivate yOffset = 0\n\n\tonEvent: MapEventHandlers = (() => {\n\t\tconst down = () => {\n\t\t\tthis.isGrabbing = true\n\t\t}\n\t\tconst up = (map: LocMap) => {\n\t\t\tthis.isGrabbing = false\n\t\t\tmap.requestRedraw()\n\t\t}\n\t\tlet zoomInTimeout = 0\n\t\tconst stopZoomIn = (map: LocMap) => {\n\t\t\tthis.isZoomIn = false\n\t\t\tmap.requestRedraw()\n\t\t}\n\t\treturn {\n\t\t\tsingleDown: down,\n\t\t\tsingleUp: up,\n\t\t\tdoubleDown: down,\n\t\t\tdoubleUp: up,\n\t\t\tmapZoom: (map, { delta }) => {\n\t\t\t\tif (delta > 1) {\n\t\t\t\t\tthis.isZoomIn = true\n\t\t\t\t\tclearTimeout(zoomInTimeout)\n\t\t\t\t\tzoomInTimeout = window.setTimeout(stopZoomIn, 100, map)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t})()\n\n\tredraw(map: LocMap) {\n\t\tconst summary = lowestLayerSummaries[this.mapCode]\n\t\tif (!summary) return\n\n\t\tif (!this.isGrabbing) {\n\t\t\tthis.xOffset *= 0.9\n\t\t\tthis.yOffset *= 0.9\n\t\t}\n\t\tlet [dLon, dLat] = this.getLonLatDelta(map, summary)\n\t\tif (this.isGrabbing || this.isZoomIn) {\n\t\t\t// В режиме увеличения границы раздвигаются вместе (одинаково) с перемещением,\n\t\t\t// так что они не мешают и не сдвигают карту. А после зума будут плавно сдвинуты обратно.\n\t\t\t// В режиме таскания границы раздвигаются медленее перемещения карты.\n\t\t\t// Это создаёт эффект \"трения\": карта у границ начинает двигаться медленее, чем курсор.\n\t\t\tconst k = this.isZoomIn ? 1 : 0.25\n\t\t\tthis.xOffset += Math.abs(dLon) * k\n\t\t\tthis.yOffset += Math.abs(dLat) * k\n\t\t\t;[dLon, dLat] = this.getLonLatDelta(map, summary)\n\t\t}\n\n\t\tconst dx = map.lon2x(dLon)\n\t\tconst dy = map.lat2y(dLat)\n\n\t\tif (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {\n\t\t\tmap.move(dx, dy)\n\t\t}\n\t}\n\n\tsetMapCode(code: MapCode) {\n\t\tthis.mapCode = code\n\t}\n\n\tprivate getLonLatDelta(map: LocMap, summary: TileLayerSummary): [number, number] {\n\t\t// eslint-disable-next-line prefer-const\n\t\tlet [layer, [left, top, right, bottom]] = summary\n\t\tright += 1\n\t\tbottom += 1\n\t\tconst layerScale = TILE_CONTENT_WIDTH * 0.5 ** layer\n\t\tleft *= layerScale\n\t\ttop *= layerScale\n\t\tright *= layerScale\n\t\tbottom *= layerScale\n\n\t\tconst [viewWidth, viewHeight] = map.getViewBoxSize()\n\t\tconst hBorder = map.x2lon(viewWidth / 2)\n\t\tconst vBorder = map.y2lat(viewHeight / 2)\n\t\tleft += hBorder\n\t\tright -= hBorder\n\t\ttop += vBorder\n\t\tbottom -= vBorder\n\n\t\tif (right < left) left = right = (left + right) / 2\n\t\tif (bottom < top) top = bottom = (top + bottom) / 2\n\t\tleft -= this.xOffset\n\t\tright += this.xOffset\n\t\ttop -= this.yOffset\n\t\tbottom += this.yOffset\n\n\t\tconst lon = map.getLon()\n\t\tconst lat = map.getLat()\n\n\t\tlet dLon = 0\n\t\tlet dLat = 0\n\t\tif (lon < left) dLon = lon - left\n\t\tif (lon > right) dLon = lon - right\n\t\tif (lat < top) dLat = lat - top\n\t\tif (lat > bottom) dLat = lat - bottom\n\t\treturn [dLon, dLat]\n\t}\n}\n","/** @returns {Promise<boolean>} */\nexport function checkAvifSupport() {\n\treturn new Promise(resolve => {\n\t\tconst img = new Image()\n\t\timg.src =\n\t\t\t'data:image/avif;base64,AAAAGGZ0eXBhdmlmAAAAAG1pZjFtaWFmAAAA621ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAHBpY3QAAAAAAAAAAAAAAAAAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABCwAAABYAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgSAAAAAAABNjb2xybmNseAABAA0ABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB5tZGF0EgAKBzgADlAQ0GkyCRAAAAAP+j9P4w=='\n\t\timg.onload = () => resolve(true)\n\t\timg.onerror = () => resolve(false)\n\t})\n}\n\n/**\n * @param {HTMLImageElement} img\n * @returns {boolean}\n */\nexport function imgIsReady(img) {\n\treturn img.complete && img.naturalWidth > 0\n}\n"],"names":["LocMap","wrap","conv","rect","getBoundingClientRect","curWidth","width","curHeight","height","lon","lat","zoom","xShift","yShift","minZoom","maxZoom","Infinity","this","getLon","getLat","getZoom","getProjConv","getShift","getViewBoxShift","getViewBoxSize","getZoomRange","setZoomRange","min","max","canvas","document","createElement","className","style","position","left","top","appendChild","rc","getContext","pos_screen2map","x2lon","y2lat","pos_map2screen","lon2x","lat2y","getWrap","getCanvas","get2dContext","meters2pixCoef","x","y","layers","register","layer","includes","Error","push","unregister","pos","indexOf","splice","getLayers","updateLocation","lon_","lat_","zoom_","updateLayers","requestRedraw","i","length","update","drawLayers","clearRect","scale","devicePixelRatio","redraw","zoomAnimationMinSpeed","zoomAnimationMode","zoomAnimationPrevStamp","zoomAnimationX","zoomAnimationY","zoomAnimationDelta","moveAnimationMode","moveAnimationPrevStamp","moveAnimationX","moveAnimationY","smoothIfNecessary","frameTime","now","Math","abs","elapsed","dz","newSmoothDelta","moveAnimationMinSpeed","dx","dy","k","move","animFrameRequested","requestAnimationFrame","onAnimationFrame","performance","resize","delta","prevZoom","mutlClamp","actualDelta","emit","zoomSmooth","stamp","moveSmooth","applyMoveInertia","applyZoomInertia","name","params","handler","onEvent","val","noop","findTouch","list","id","identifier","mustFindTouch","touch","addListener","event","addEventListener","capture","passive","removeListener","removeEventListener","point_distance","x1","y1","x2","y2","sqrt","getApproximatedSpeed","items","attr","timeStamp","sumx","sumy","sumx2","sumxy","n","len","last","cur","prev","dtime","dattr","aDenom","a","PointerControlLayer","opts","doNotInterfere","control","mouseX","mouseY","moveDistance","lastSingleClickAt","lastDoubleTouchParams","lastDoubleTouch_cx","lastDoubleTouch_cy","lastDoubleTouch_dx","lastDoubleTouch_dy","lastDoubleTouch_dist","lastDoubleTouch_stamp","lastMoves","lastZooms","dist","arr","Object","assign","peekOrShift","newLast","shift","recordMousePos","moveRecordedMousePos","setCorrectedSinglePos","timeDelta","b","clamp","shouldShowTwoFingersHint","e","makeControl","map","cursor","callbacks","startElem","moveElem","leaveElem","offsetElem","mouseDownEvt","mouseMoveEvt","mouseUpEvt","wheelEvt","mouseHoverEvt","mouseLeaveEvt","touchStartEvt","touchMoveEvt","touchEndEvt","touchCancelEvt","singleDown","singleMove","singleUp","doubleDown","doubleMove","doubleUp","singleHover","singleLeave","wheelRot","touchIds","getOffsetElem","func","elem","preventDefault","mousedown","button","clientX","clientY","mousemove","mouseup","mousemoveHover","mouseleave","touchstart","curCount","changedTouches","t","t0","t1","prevent","touches","prevetUp","x0","y0","preventDouble","touchmove","releasedTouches","touchend","tid0","tid1","j","tLast","preventUp2","preventDown1","preventUp1","touchcancel","mousewheel","deltaMode2pixels","WheelEvent","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","deltaMode","deltaX","deltaY","deltaZ","makeWheelListener","getEvents","events","isOn","on","elems","off","makeEventsToggler","window","defaultElem","controlDouble","isSwitching","focus","type","oldX","oldY","eventTimeStamp","applyInertia","id0","id1","isDbl","cx","cy","cd","centerX","centerY","distance","recordTouchDist","ctrlKey","metaKey","pow","KeyboardControlLayer","outlineFix","oldTabIndex","tabIndex","outline","altKey","shouldPrevent","key","shiftKey","moveDelta","zoomDelta","makeHandler","ControlLayer","mouseOpts","kbdOpts","item","SmoothTileContainer","tileW","tileLoadFunc","tilePlaceholderDrawFunc","cache","Map","lastDrawnTiles","Set","lastDrawnUnderLevelTilesArr","prevTileRegion","drawIter","findTile","level","loadIfMissing","tile","get","z","img","clear","appearAt","lastDrawIter","makeTile","set","canFullyDrawRecentTile","useOpacity","tileDrawnRecently","getTileOpacity","tryDrawTile","tileX","tileY","tileZ","tryDrawTileObj","dlevel","dzoom","di","dj","imgW","isHtmlImg","naturalWidth","sx","sy","sw","dw","withOpacity","sh","w","h","iFrom","jFrom","iCount","jCount","tileWasOutsideOnCurLevel","add","s","rx","round","ry","alpha","globalAlpha","drawImage","drawTile","drawOneTile","shouldLoad","canFillByQuaters","upperTileDrawn","topLevel","log2","l","sub","lowerTilesDrawn","draw","mapViewWidth","mapViewheight","tileViewSizeExt","ceil","forEach","cacheMaxSize","attempt","size","oldestIter","delete","getTileWidth","clearCache","TileLayer","tileContainer","shouldLoadTiles","lastZoomAt","curZoomTotalDelta","tileLoadOffTimeout","tileLoadPausedAt","floor","tileGridSize","blockSize","mapXShift","mapYShift","mapViewHeight","mapZoom","durationMS","clearTimeout","setTimeout","pauseTileLoad","decodeLayerMask","maskStr","code","isExtra","rangeEndI","mask","Uint8Array","rangeStartI","charCodeAt","fill","makeTileMaskChecker","layersInfo","level2func","right","bottom","TILE_CONTENT_WIDTH","tileExt","Promise","resolve","Image","src","onload","onerror","then","ok","TILES_ROOT","lowestLayerSummaries","tilesMask","fetch","r","json","summaries","MapProjection","TeyvatMap","classes","mapCode","markers","wrapRef","mapRef","mapCodeRef","current","shouldDrawTile","loadTileInner","pathFunc","tilePathFinc","onUpdate","clearHtmlImg_","clearHtmlImg","createImageBitmap","close","clearBitmapImg","drawX","drawY","strokeStyle","strokeRect","margin","drawRectTilePlaceholder","markersLayer","MarkersLayer","movementClampLayer","MovementClampLayer","m","setMapCode","setMarkers","xMin","xMax","yMin","yMax","marker","calcAutoPosition","ref","class","backgroundColor","iconCache","loadMarkerImg","cachedIcon","icon","blur","color","naturalHeight","shadowBlur","shadowColor","makeCanvasWithShadow","rawMarkers","keys","raw","viewX","viewY","zoomDownscale","lineW","isCircled","beginPath","arc","PI","fillStyle","isImg","nw","nh","save","clip","restore","lineWidth","stroke","isGrabbing","isZoomIn","xOffset","yOffset","down","up","zoomInTimeout","stopZoomIn","summary","dLon","dLat","getLonLatDelta","layerScale","viewWidth","viewHeight","hBorder","vBorder"],"sourceRoot":""}